/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <soundinfo>

#include <GamePlay_Included/Tools.inc>

#define PLUGIN "[MAP] Weather"
#define VERSION "1.0"
#define AUTHOR "Nguyen Duy Linh"

#define CONFIGURATION_FILE "TFM_MapWeatherCfg.ini"



#define TASK_PLAY_WIND_SOUND	2000
#define TASK_PLAY_THUNDER_SOUND	3000
#define TASK_PLAY_LIGHTING	4000
#define TASK_PLAY_RAIN_SOUND	5000

enum
{
	WEATHER_DEFAULT,
	WEATHER_RAIN,
	WEATHER_FOG,
	WEATHER_SNOW
}

enum
{
	LIGHT_NO,
	LIGHT_YES
}


#define FSetBit(%1,%2)      (%1 |= (1<<(%2&31)))
#define FClearBit(%1,%2)    (%1 &= ~(1 <<(%2&31)))
#define FCheckBit(%1,%2)    (%1 & (1<<(%2&31)))

enum
{
	FLAG_WEATHER,
	FLAG_SKY_NAME,
	FLAG_SKY_LIGHT,
	FLAG_WIND,
	FLAG_THUNDER,
	FLAG_LIGHTING,
	FLAG_LIGHTING_MIN,
	FLAG_LIGHTING_MAX
	
}

enum
{
	LIGHT_NO,
	LIGHT_YES
}

new Trie:TRIE_WeatherInfo

new Array:ARRAY_WindSound
new Array:ARRAY_ThunderSound

new FLAG_iWeatherInfo

#define TRIE_FIELD_SKY		"SKY"
#define TRIE_FIELD_LIGHT	"LIGHT"
#define TRIE_FIELD_LIGHTING	"LIGHTING"

#define LIGHTING_MIN_HOLDTIME	0.15
#define LIGHTING_MAX_HOLDTIME	0.3

#define TRIE_FIELD_LIGHTING_TIME_MIN		"LIGHTING_TIME_MIN"
#define TRIE_FIELD_LIGHTING_TIME_MAX		"LIGHTING_TIME_MAX"

new Float:LIGHTING_MIN_TIME	=	2.0
new Float:LIGHTING_MAX_TIME	=	10.0


				
new WEATHER_iLightStage

new ifw_MapLightStyle


new MAP_LIGHT_LEVEL_STRING[][] = {"a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", 
				"q", "r", "s", "t", "u", "v", "w", "x", "y", "z"}
				
public plugin_precache()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	// Build customization file path
	new path[64]
	get_configsdir(path, charsmax(path))
	
	formatex(path, charsmax(path), "%s/%s", path, CONFIGURATION_FILE)
	
	// File not present
	if (!file_exists(path))
		return;
	
	// Set up some vars to hold parsing info
	new linedata[1024], key[64], value[960]
	
	// Open customization file for reading
	new file = fopen(path, "rt")
	
	new iMapDetected = 0
	new szMapName[32]
	get_mapname(szMapName, sizeof szMapName - 1)
	
	while (file && !feof(file))
	{
		// Read one line at a time
		fgets(file, linedata, charsmax(linedata))
		
		// Replace newlines with a null character to prevent headaches
		replace(linedata, charsmax(linedata), "^n", "")
		
		// Blank line or comment
		if (!linedata[0] || linedata[0] == ';') continue;
		
		if (linedata[0] == '[')
		{	
			if (iMapDetected)
				break;
				
			replace(linedata, sizeof linedata - 1, "[", "")
			replace(linedata, sizeof linedata - 1, "]", "")
			
			server_print("Compare %s with %s", szMapName, linedata)
			if (equal(szMapName, linedata))
			{
				iMapDetected = 1
				TRIE_WeatherInfo = TrieCreate()
			}
			continue;
		}
		else
		{
			if (!iMapDetected)
				continue
				
			
			// Get key and value(s)
			strtok(linedata, key, charsmax(key), value, charsmax(value), '=')
			
			// Trim spaces
			trim(key)
			
			if (equal(key, "WEATHER") && !FCheckBit(FLAG_iWeatherInfo, FLAG_WEATHER))
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_WEATHER)
				
				new iWEATHER_TYPE = str_to_num(value)
				if (iWEATHER_TYPE == WEATHER_RAIN)
					create_entity("env_rain")
				else if (iWEATHER_TYPE == WEATHER_SNOW)
					create_entity("env_snow")
			}
			else if (equal(key, "SKY_NAME") && !FCheckBit(FLAG_iWeatherInfo, FLAG_SKY_NAME))	
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_SKY_NAME)
				TrieSetString(TRIE_WeatherInfo, TRIE_FIELD_SKY, value)
				
				if (!equal(value, "|", 1))
					set_cvar_string("sv_skyname", value)
				else
					load_default_sky()
				
			}
			else if (equal(key, "SKY_LIGHT") && !FCheckBit(FLAG_iWeatherInfo, FLAG_SKY_LIGHT))	
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_SKY_LIGHT)
				
				if (!equal(value, "|"))
				{
					set_lights(value[0])
					TrieSetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHT, get_light_level(value[0]))
					server_print("LIGHT LEVEL = %d = %s", get_light_level(value[0]), MAP_LIGHT_LEVEL_STRING[get_light_level(value[0])])
				}
				else
				{
					if (!ifw_MapLightStyle)
						ifw_MapLightStyle = register_forward(FM_LightStyle, "fw_GetMapLightStyle", 1)
				}
			}
			else if (equal(key, "WIND") && !FCheckBit(FLAG_iWeatherInfo, FLAG_WIND))	
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_SKY_LIGHT)
				
				ARRAY_WindSound = ArrayCreate(64, 1)
				
				while (value[0] != 0 && strtok(value, key, charsmax(key), value, charsmax(value), ','))
				{
					// Trim spaces
					trim(key)
					trim(value)
						
					// Add to sounds array
					ArrayPushString(ARRAY_WindSound, key)
				}	
				
				
			
			}
			else if (equal(key, "THUNDER") && !FCheckBit(FLAG_iWeatherInfo, FLAG_THUNDER))
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_THUNDER)
				
				ARRAY_ThunderSound = ArrayCreate(64, 1)
				
				while (value[0] != 0 && strtok(value, key, charsmax(key), value, charsmax(value), ','))
				{
					// Trim spaces
					trim(key)
					trim(value)
						
					// Add to sounds array
					ArrayPushString(ARRAY_ThunderSound, key)
				}
				
				
				if (task_exists(TASK_PLAY_THUNDER_SOUND))
					remove_task(TASK_PLAY_THUNDER_SOUND)
						
				set_task(1.0, "TASK_PlayThunderSound", TASK_PLAY_THUNDER_SOUND)
					
				
			}
			else if (equal(key, "LIGHTING") && !FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING))
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_LIGHTING)
				trim(value)
				TrieSetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING, get_light_level(value[0]))
			}
			else if (equal(key, "LIGHT_MIN_TIME") && !FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MIN))
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MIN)
				trim(value)
				TrieSetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING_TIME_MIN, str_to_float(value))
			}
			else if (equal(key, "LIGHT_MAX_TIME") && !FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MAX))
			{
				FSetBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MAX)
				trim(value)
				TrieSetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING_TIME_MAX, str_to_float(value))
			}
		}
	}	
	
	if (!FCheckBit(FLAG_iWeatherInfo, FLAG_SKY_NAME))
		load_default_sky()
		
	
	
}

public plugin_init()
{
	if (ifw_MapLightStyle)
		unregister_forward(FM_LightStyle, ifw_MapLightStyle, 1)
		
	if (FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING))
	{
		if (task_exists(TASK_PLAY_LIGHTING))
			remove_task(TASK_PLAY_LIGHTING)
				
		new iParam[2]
		TrieGetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHT, iParam[0])
		TrieGetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING, iParam[1])
		
		if (FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MIN) && FCheckBit(FLAG_iWeatherInfo, FLAG_LIGHTING_MAX))
		{
			TrieGetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING_TIME_MIN, LIGHTING_MIN_TIME)
			TrieGetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHTING_TIME_MAX, LIGHTING_MAX_TIME)
		}
		set_task(1.0, "TASK_PlayLighting", TASK_PLAY_LIGHTING, iParam, sizeof iParam)
	}
	
	if (FCheckBit(FLAG_iWeatherInfo, FLAG_WIND))
	{
		if (task_exists(TASK_PLAY_WIND_SOUND))
			remove_task(TASK_PLAY_WIND_SOUND)
			
		set_task(1.0, "TASK_PlaySoundOfWind", TASK_PLAY_WIND_SOUND)
	}
	
	if (FCheckBit(FLAG_iWeatherInfo, FLAG_THUNDER))
	{
		if (task_exists(TASK_PLAY_THUNDER_SOUND))
			remove_task(TASK_PLAY_THUNDER_SOUND)
						
		set_task(1.0, "TASK_PlayThunderSound", TASK_PLAY_THUNDER_SOUND)
	}
}


public fw_GetMapLightStyle(iStyle, szMapLight[])
{
	if (!iStyle)
		return
		
	TrieSetCell(TRIE_WeatherInfo, TRIE_FIELD_LIGHT, get_light_level(szMapLight[0]))
}

public TASK_PlayLighting(iParam[2], TASKID)
{
	if (WEATHER_iLightStage!= LIGHT_YES)
	{
		new iRandomLight = random_num(iParam[0], iParam[1])
			
		set_lights(MAP_LIGHT_LEVEL_STRING[iRandomLight])
		
		WEATHER_iLightStage = LIGHT_YES
		
		new Float:fLightTime = random_float(LIGHTING_MIN_HOLDTIME, LIGHTING_MAX_HOLDTIME)
		
		set_task(fLightTime, "TASK_PlayLighting", TASKID, iParam, sizeof iParam)
	}
	else
	{
		WEATHER_iLightStage = LIGHT_NO
		set_lights(MAP_LIGHT_LEVEL_STRING[iParam[0]])
		
		new Float:fLightTime = random_float(LIGHTING_MIN_TIME, LIGHTING_MAX_TIME)
		set_task(fLightTime, "TASK_PlayLighting", TASKID, iParam, sizeof iParam)
	}
	
	
}
public TASK_PlaySoundOfWind(TASKID)
{
	new iRandomSound = random(ArraySize(ARRAY_WindSound))
	
	new szFileName[128]
	ArrayGetString(ARRAY_WindSound, iRandomSound, szFileName, sizeof szFileName - 1)
	
	switch ( sfile_type(szFileName)) 
	{
		case SFILE_WAV:
			client_cmd(0, "spk %s", szFileName)
		case SFILE_MP3:
			client_cmd(0, "mp3 play ^"%s^"", szFileName);  
	}
	new iData[SParam]
	 
	if(sfile_loaddata(szFileName, iData) == SRES_OK)
	{
		new Float:fDuration = sfile_get_duration(szFileName) 
		set_task(fDuration, "TASK_PlaySoundOfWind", TASKID)
	}
}

public TASK_PlayThunderSound(TASKID)
{
	
	new iRandomSound = random(ArraySize(ARRAY_ThunderSound))
	
	new szFileName[128]
	ArrayGetString(ARRAY_ThunderSound, iRandomSound, szFileName, sizeof szFileName - 1)
	
	switch ( sfile_type(szFileName)) 
	{
		case SFILE_WAV:
			client_cmd(0, "spk %s", szFileName)
		case SFILE_MP3:
			client_cmd(0, "mp3 play ^"%s^"", szFileName);  
	}
	new iData[SParam]
	 
	if(sfile_loaddata(szFileName, iData) == SRES_OK)
	{
		new Float:fDuration = sfile_get_duration(szFileName) 
		set_task(fDuration, "TASK_PlayThunderSound", TASKID)
	}
	
}

stock fm_set_kvd(entity, const key[], const value[], const classname[])
{
	set_kvd(0, KV_ClassName, classname)
	set_kvd(0, KV_KeyName, key)
	set_kvd(0, KV_Value, value)
	set_kvd(0, KV_fHandled, 0)

	dllfunc(DLLFunc_KeyValue, entity, 0)
}

stock get_light_level(szLightLevel)
{
	new MAP_LIGHT_LEVEL[] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 
				'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}
		
	for (new iLight = 0 ; iLight < sizeof MAP_LIGHT_LEVEL; iLight++)
		if (szLightLevel == MAP_LIGHT_LEVEL[iLight])
			return iLight
		
	return - 1
}


stock load_default_sky()
{
	new szMapName[32]
	get_mapname(szMapName, sizeof szMapName - 1)
	
	new szFile[128], szBuffer[64]
	formatex(szFile, sizeof szFile - 1, "maps/%s.bsp", szMapName)
	
	new bool:bInEntityDatas
	
	new fp = fopen(szFile, "rb")
	
	new iOffset, iLength, iMaxPos
	fseek(fp, 4, SEEK_SET)
	fread(fp, iOffset, BLOCK_INT)
	fread(fp, iLength, BLOCK_INT)
	iMaxPos = iOffset + iLength
	fseek(fp, iOffset, SEEK_SET)
	
	while( ftell(fp) < iMaxPos )
	{
		fgets(fp, szBuffer, charsmax(szBuffer))
		trim(szBuffer)

		if( bInEntityDatas )
		{
			if( szBuffer[0] == '}' )
			{
				bInEntityDatas = false
				
			}
			else
			{
				new szKey[32], szValue[32]
				parse(szBuffer, szKey, charsmax(szKey), szValue, charsmax(szValue))
				
				if (equal(szKey, "skyname"))
				{
					set_cvar_string("sv_skyname", szValue)
					return
				}
				
			}
		}
		else if( szBuffer[0] == '{' )
			bInEntityDatas = true
	}
	
	fclose(fp)
}
