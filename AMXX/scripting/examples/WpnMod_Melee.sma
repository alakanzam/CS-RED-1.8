/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <cstrike>
#include <fakemeta>
#include <hamsandwich>
#include <xs>
#include <engine>
#include <cstrike>
#include <fakemeta_util>
#include <mmcl_util>

#include <weaponbox_info>
#include <ArmouryManager>
#include <cswpn_ultilities>
#include <celltrie>
#include <cstrike_pdatas>
#include <cswpn_ultilities>



#include <WpnMod_Included/LineInfo_Melee.inc>
#include <WpnMod_Included/WM_COMMAND.inc>
#include <WpnMod_Included/WM_GlobalConstant.inc>

#define max_wpn 32



#define TASK_KNIFE_FIRST_ATK	3000
#define TASK_KNIFE_SECOND_ATK	4000


new Trie:weapon_StringInfo[max_wpn]
new Trie:iLoadedFile
new Trie:iPrecachedModel

/*				TRIE KEY					*/

//	String

#define SECTION_WEAPON_NAME	"WEAPON_NAME"
#define SECTION_WEAPON_HUD	"WEAPON_HUD"
#define SECTION_WEAPON_SPAWN_FILE	"WEAPON_SPAWN_FILE"
#define SECTION_WEAPON_CLASS	"WEAPON_CLASS"

#define SECTION_SOUND_HITBODY	"HITBODY"
#define SECTION_SOUND_SLASH	"SLASH"
#define SECTION_SOUND_STAB	"STAB"
#define SECTION_SOUND_HITWALL	"HITWALL"
#define SECTION_BACK_MODEL	"BACKMODEL_SECTION"

#define SECTION_WEAPON_SEQ	"WEAPON_SEQ"
#define SECTION_WEAPON_SERIAL	"WEAPON_SERIAL"


#define SECTION_V_MODEL	"V_MODEL"
#define SECTION_W_MODEL	"W_MODEL"
#define SECTION_P_MODEL	"P_MODEL"

#define SECTION_KNOCKBACK_DISTANCE "KNOCKBACK_DISTANCE"
//	Integer
#define SECTION_V_SUB	"V_SUB"
#define SECTION_P_SUB	"P_SUB"
#define SECTION_W_SUB	"W_SUB"

#define SECTION_WPN_COST	"WPN_COST"
#define SECTION_WPN_COST_TYPE	"WPN_COST_TYPE"
#define SECTION_WPN_LEVEL	"WPN_LEVEL"
#define SECTION_WPN_REMOVE	"WPN_REMOVE"

#define SECTION_FIRST_ATK_TYPE	"FIRST_ATK_TYPE"
#define SECTION_SECOND_ATK_TYPE	"SECOND_ATK_TYPE"
//	Float
#define SECTION_WPN_DAMAGE_1	"WPN_DAMAGE_1"
#define SECTION_WPN_DAMAGE_2	"WPN_DAMAGE_2"

#define SECTION_WPN_DMGBIT_1	"WPN_DMGBIT_1"
#define SECTION_WPN_DMGBIT_2	"WPN_DMGBIT_2"

#define SECTION_WPN_RANGE_1	"WPN_RANGE_1"
#define SECTION_WPN_RANGE_2	"WPN_RANGE_2"

#define SECTION_WPN_DEPLOY_TIME	"DEPLOY_TIME"
#define SECTION_WPN_WEIGTH	"WPN_WEIGHT"
#define SECTION_SPEED_REDUCTION	"SPEED_REDUCTION"
#define SECTION_KNOCKBACK_POWER	"KNOCKBACK_POWER"

#define SECTION_ATTACK_TIME_1	"ATTACK_TIME_1"
#define SECTION_ATTACK_TIME_2	"ATTACK_TIME_2"

#define SECTION_DMG_DELAY_1	"DMG_DELAY_1"
#define SECTION_DMG_DELAY_2	"DMG_DELAY_2"
/********************************************************************************/



#define HIT_SHIELD	8




new g_weapon_count = 0




const m_fKnown				= 44

enum
{
	ANIM_IDLE,
	ANIM_SLASH1,
	ANIM_SLASH2,
	ANIM_DRAW,
	ANIM_STAB,
	ANIM_STAB_MISS,
	ANIM_MIDSLASH1,
	ANIM_MIDSLASH2
}

new iHasWeapon[33]

			
			
new iArmouryMenuId

#define MAX_CLASS 64

#define MAX_SPAWN_POINT 255
new Float:fSpawnVecs[MAX_SPAWN_POINT][3]
new iTotalSpawnPoint
new iSpawnWeaponId[MAX_SPAWN_POINT]


/*			BIT TOOLS			*/
#define SetPlayerBit(%1,%2)      (%1 |= (1<<(%2&31)))
#define ClearPlayerBit(%1,%2)    (%1 &= ~(1 <<(%2&31)))
#define CheckPlayerBit(%1,%2)    (%1 & (1<<(%2&31)))

/********************************************************/


/*			BIT FIELD			*/

new pBit_DontTrace
new pBit_SecondSeq

/********************************************************/


#define WPN_CONFIG_DIR	"WPN_MOD/MELEE/CONFIGS"
#define WPN_SPAWN_DIR	"WPN_MOD/MELEE/SPAWN"
#define WPN_SPEC_DIR	"WPN_MOD/MELEE/SPEC"
#define WPN_ADD_DIR	"WPN_MOD/MELEE/ADD"
#define WPN_MANAGER_DIR	"WPN_MOD/MELEE"
#define	WPN_MANAGER_FILE	"MANAGER.CFG"

//		FORWARDS

new ifw_MeleeCheckSerial
new ifw_ArmouryPickedUp

new ifw_UserCanTouchWpnBox
new ifw_UserCanTouchArmoury
new ifw_UserCanEquipWpn
new ifw_ArmouryEntitySpawn
new ifw_WeaponLoaded

new ifw_Result


new iMSGID_DeathMsg


/***************************************************************/
public plugin_natives()
{
	register_native("give_user_melee", "nt_give_user_melee", 1)
	register_native("set_user_melee", "nt_set_user_melee", 1)
	register_native("get_melee_hud", "nt_get_melee_hud", 1)
	register_native("get_user_melee", "nt_get_user_melee", 1)
	register_native("get_melee_name", "nt_get_melee_name", 1)
	register_native("get_melee_number", "nt_get_melee_number", 1)
	register_native("find_melee_by_model", "nt_find_melee_by_model", 1)
	register_native("find_melee_by_serial", "nt_find_melee_by_serial", 1)
	register_native("get_melee_cost", "nt_get_melee_cost", 1)
	register_native("get_melee_cost_type", "nt_get_melee_cost_type", 1)
	register_native("get_melee_weight", "nt_get_melee_weight", 1)
	register_native("get_melee_speed", "nt_get_melee_speed", 1)
	register_native("get_melee_level", "nt_get_melee_level", 1)
	register_native("set_melee_load_file", "nt_set_melee_load_file", 1)
	register_native("set_melee_spawn", "nt_set_melee_spawn", 1)
	register_native("get_melee_kb_power", "nt_get_melee_kb_power", 1)
	register_native("get_melee_kb_distance", "nt_get_melee_kb_distance", 1)
	register_native("is_valid_melee", "nt_is_valid_melee", 1)
}

public nt_give_user_melee(id, iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
	{
		nt_set_user_melee(id, -1)
		return
	}
	
	if (!can_player_equip_melee(id))
		return
		
	nt_set_user_melee(id, iMeleeId)
	UT_StripPlayerWeapon(id, "weapon_knife")
	new iEnt = fm_give_item(id, "weapon_knife")
	
	if (!pev_valid(iEnt))
		return
		
	engclient_cmd(id, "weapon_knife")
	ExecuteHamB(Ham_Item_Deploy, iEnt)
	
	new szWeaponClass[64]
	
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_CLASS, szWeaponClass, sizeof szWeaponClass - 1)
	UT_UpdateWpnList(id, CSW_KNIFE, 1, szWeaponClass, 0, 1)
}

public nt_set_user_melee(id, iMeleeId)
{
	iHasWeapon[id] = iMeleeId
}

public nt_get_melee_hud(iMeleeId, szHUD[], iLen)
{
	param_convert(2)
	
	if (!nt_is_valid_melee(iMeleeId))
		return
	
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_HUD, szHUD, iLen)
}

public nt_get_user_melee(id)
{
	if (!is_user_connected(id))
		return -1
		
	return iHasWeapon[id]
}

public nt_get_melee_name(iMeleeId, szName[], iLen)
{
	param_convert(2)
	
	if (!nt_is_valid_melee(iMeleeId))
		return
	
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_NAME, szName, iLen)
}

public nt_get_melee_number()
	return g_weapon_count
	
public nt_find_melee_by_model(szModel[])
{
	param_convert(1)
	
	return _find_melee_by_model(szModel)
}

public nt_find_melee_by_serial(szSerial[])
{
	param_convert(1)
	
	for (new i = 0; i < g_weapon_count; i++)
	{
		new szRealSerial[64]
		TrieGetString(weapon_StringInfo[i], SECTION_WEAPON_SERIAL, szRealSerial, sizeof szRealSerial - 1)
		
		if (!equal(szSerial, szRealSerial))
			continue
			
		return i
	}
	return -1
}

public nt_get_melee_cost(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return -1
		
	new iCost
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_COST , iCost)
	return iCost
}

public nt_get_melee_cost_type(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return -1
		
	new iCostType
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_LEVEL, iCostType)
	return iCostType
}

public Float:nt_get_melee_weight(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return 0.0
		
	new Float:fMeleeWeight
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_WEIGTH, fMeleeWeight)
	return fMeleeWeight
}

public Float:nt_get_melee_speed(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return 0.0
		
	new Float:fSpeedReduction
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_SPEED_REDUCTION, fSpeedReduction)
	return fSpeedReduction
}

public nt_get_melee_level(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return -1
		
	new iLevel
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_LEVEL, iLevel)
	return iLevel
}

public nt_set_melee_load_file(szFile[], szExtension[], iIgnore_AllConditions)
{
	param_convert(1)
	param_convert(2)
	
	
	load_melee_file(WPN_CONFIG_DIR, szFile, szExtension, iIgnore_AllConditions)
}

public nt_set_melee_spawn(iPoint, iMeleeId, Float:fOrigin[3])
	CreateArmoury(iPoint, iMeleeId, fOrigin)
	
public Float:nt_get_melee_kb_power(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return 0.0
		
	new Float:fKnockBackPower
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_KNOCKBACK_POWER, fKnockBackPower)
	return fKnockBackPower
}

public nt_get_melee_kb_distance(iMeleeId)
{
	if (!nt_is_valid_melee(iMeleeId))
		return 0
		
	new iKnockBackDistance
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_KNOCKBACK_DISTANCE, iKnockBackDistance)
	return iKnockBackDistance
}

public nt_is_valid_melee(iMeleeId)
{
	if (iMeleeId < 0 || iMeleeId > g_weapon_count - 1)
		return 0
	
	return 1
}


public plugin_init() 
{
	
	#define	PLUGIN 	 "[WPN] Melee"
	#define	VERSION 	 "-[No Info]-"
	#define	AUTHOR 	 "Nguyen Duy Linh"
	
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	for (new i = 0; i < max_wpn; i++)
		weapon_StringInfo[i] = TrieCreate()
	
	if (!iLoadedFile)
		iLoadedFile = TrieCreate()
	
	forward_register()
	
	register_dictionary("TFM_Dictionary.txt")
	
	iMSGID_DeathMsg = get_user_msgid("DeathMsg")
	
	register_concmd(MELEE_ARMOURY_CMD, "concmd_OpenArmouryMenu", ADMIN_ALL)
	
	
	register_event("35", "event_weapon_anim", "b")

	register_logevent("round_begin" , 2 , "1=Round_Start")
	register_event("HLTV", "Event_RoundStart", "a", "1=0", "2=0")
	
	register_message(get_user_msgid("DeathMsg"), "message_DeathMsg")
	
	
	new szMenuTitle[128]
	
	formatex(szMenuTitle, sizeof szMenuTitle - 1, "%L", 0, "ARMOURY_TITLE")
	iArmouryMenuId = menu_create(szMenuTitle, "fw_ArmouryMenuSelected")
	
	register_forward(FM_SetModel, "fw_SetModelPost", 1)
	register_forward(FM_EmitSound, "fw_emitsound")
	register_forward(FM_CmdStart, "fw_CmdStart")
	
	register_forward(FM_TraceLine, "OnTraceLine")
	register_forward(FM_TraceHull, "OnTraceHull")
	
	
	register_touch("weaponbox", "player", "fw_WpnBoxTouch")
	register_touch("armoury_entity", "player", "fw_ArmouryTouched")	
	
	new szMapName[32], szCfgDir[128]
	
	get_mapname(szMapName, sizeof szMapName - 1)
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	
	new szManagerFile[256]
	formatex(szManagerFile, sizeof szManagerFile - 1, "%s/%s/%s.cfg", szCfgDir, WPN_SPEC_DIR, szMapName)
	
	if (file_exists(szManagerFile))
	{
		for (new i = 0; i < file_size(szManagerFile, 1); i++)
		{
			new szTextInfo[64], iTextLen
			read_file(szManagerFile, i, szTextInfo, sizeof szTextInfo - 1, iTextLen)
			load_melee_file(WPN_CONFIG_DIR, szTextInfo, "ini", 1)
		}
	}
	else
	{
		formatex(szManagerFile, sizeof szManagerFile - 1, "%s/%s/%s", szCfgDir, WPN_MANAGER_DIR, WPN_MANAGER_FILE)
	
		if (file_exists(szManagerFile))
		{
			for (new i = 0; i < file_size(szManagerFile, 1); i++)
			{
				new szTextInfo[64], iTextLen
				read_file(szManagerFile, i, szTextInfo, sizeof szTextInfo - 1, iTextLen)
				load_melee_file(WPN_CONFIG_DIR, szTextInfo, "ini", 0)
			}
		}
	}
	
	formatex(szManagerFile, sizeof szManagerFile - 1, "%s/%s/%s.cfg", szCfgDir, WPN_ADD_DIR, szMapName)
	
	if (file_exists(szManagerFile))
	{
		for (new i = 0; i < file_size(szManagerFile, 1); i++)
		{
			new szTextInfo[64], iTextLen
			read_file(szManagerFile, i, szTextInfo, sizeof szTextInfo - 1, iTextLen)
			load_melee_file(WPN_CONFIG_DIR, szTextInfo, "redplane", 1)
		}
	}
	
}



public client_connect(id)
	nt_set_user_melee(id, -1)


public clcmd_select_weapon(id)
	engclient_cmd(id, "weapon_knife")
	
public concmd_OpenArmouryMenu(id)
{
	if (!is_user_alive(id))
		return
		
	if (!is_user_admin(id))
		return
		
	menu_display(id, iArmouryMenuId, 0)
}
	
public event_weapon_anim()
{
	// Because of a weird bug within the AMXX event system, we need to
	// hook this message to prevent some weird behavior when calling
	// engclient_cmd(id, "weapon_knife") in the CurWeapon Event forward.
	// http://forums.alliedmods.net/showthread.php?t=85161&page=2
}

public round_begin()
{
	for (new i = 0; i < iTotalSpawnPoint; i++)
		CreateArmoury(i, -1, Float:{0.0, 0.0, 0.0})
}

public Event_RoundStart()
{	
}

public OnTraceLine(Float:vector_start[3], Float:vector_end[3], ignored_monster, id, handle)
{
	if (!is_user_alive(id))
		return FMRES_IGNORED
	
	if (get_user_weapon(id) != CSW_KNIFE)
		return FMRES_IGNORED
	
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return FMRES_IGNORED
		
	if (CheckPlayerBit(pBit_DontTrace, id))
	{
		pev(id, pev_v_angle, vector_end)
		angle_vector(vector_end, ANGLEVECTOR_FORWARD, vector_end)
		xs_vec_mul_scalar(vector_end, 0.0, vector_end)
		xs_vec_add(vector_start, vector_end, vector_end)
		engfunc(EngFunc_TraceLine, vector_start, vector_end, ignored_monster, id, handle)
		
		
		return FMRES_SUPERCEDE;
	}
	return FMRES_IGNORED
}

public OnTraceHull(Float:vector_start[3], Float:vector_end[3], ignored_monster, hull, id, handle)
{
	if (!is_user_alive(id))
		return FMRES_IGNORED
	
	if (get_user_weapon(id) != CSW_KNIFE)
		return FMRES_IGNORED
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return FMRES_IGNORED
		
	if (CheckPlayerBit(pBit_DontTrace, id))
	{
		pev(id, pev_v_angle, vector_end)
		angle_vector(vector_end, ANGLEVECTOR_FORWARD, vector_end)
		xs_vec_mul_scalar(vector_end, 0.0, vector_end)
		xs_vec_add(vector_start, vector_end, vector_end)
		engfunc(EngFunc_TraceHull, vector_start, vector_end, ignored_monster, hull, id, handle)
		return FMRES_SUPERCEDE
	}
	return FMRES_IGNORED
}
	
public message_DeathMsg(msg_id, msg_dest, msg_entity)
{
	new szTruncatedWeapon[33], iAttacker
	get_msg_arg_string(4, szTruncatedWeapon, charsmax(szTruncatedWeapon))
	// Get attacker and victim
	iAttacker = get_msg_arg_int(1)

	
	
	if(!is_user_connected(iAttacker))
		return PLUGIN_CONTINUE
		
	if(equal(szTruncatedWeapon, "knife"))
	{
		new iMeleeId = nt_get_user_melee(iAttacker)
		
		if (iMeleeId > -1)
		{
			new szHudKill[64]
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_HUD, szHudKill, sizeof szHudKill - 1)
			
			if (!equal(szHudKill, "knife"))
			{
				set_msg_arg_string(4, "")
				return PLUGIN_HANDLED
			}
		}
	}
	return PLUGIN_CONTINUE
}

public fw_ArmouryMenuSelected(id, iMenuId, iItemId)
{
	if (!is_user_alive(id))
		return
		
	if (iItemId == MENU_EXIT)
		return
	
	if (iTotalSpawnPoint > MAX_SPAWN_POINT - 1)
		return
		
	new szItemName[32], szInfo[3], iCALL_BACK, iACCESS_TYPE
	menu_item_getinfo(iMenuId, iItemId, iACCESS_TYPE, szInfo, sizeof szInfo - 1, szItemName, sizeof szItemName - 1, iCALL_BACK)
	
	new iWeaponId = str_to_num(szInfo)
	
	new szCfgDir[128], szMapName[32]
	
	get_mapname(szMapName, sizeof szMapName - 1)
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	
	new szWeaponDirectory[256]
	formatex(szWeaponDirectory, sizeof szWeaponDirectory - 1, "%s/g4u_weapon/knife/weapon_spawn/%s", szCfgDir, szMapName)
	
	if (!dir_exists(szWeaponDirectory))
		mkdir(szWeaponDirectory)
		
	new iOrigin[3]
	get_user_origin(id, iOrigin, 0)
	
	new line[128]
	format(line, 127, "%d %d %d", iOrigin[0] ,iOrigin[1], iOrigin[2])
	
	new szSpawnFile[128]
	TrieGetString(weapon_StringInfo[iWeaponId], SECTION_WEAPON_SPAWN_FILE, szSpawnFile, sizeof szSpawnFile - 1)
	
	write_file(szSpawnFile, line, -1)
	
	IVecFVec(iOrigin, fSpawnVecs[iTotalSpawnPoint])
	
	menu_display(id, iMenuId, 0)
	iSpawnWeaponId[iTotalSpawnPoint] = iWeaponId
	iTotalSpawnPoint++
}

public fw_SetModelPost(iEnt, szModel[])
{	
	if (!pev_valid(iEnt))
		return
		
	new szClassName[32]
	pev(iEnt, pev_classname, szClassName, 31)
	
	if (!equal(szClassName, "weaponbox"))
		return
	
	if (!equal(szModel, "models/w_knife.mdl"))
		return
		
	new iOwner = pev(iEnt, pev_owner)
	
	new iMeleeId = nt_get_user_melee(iOwner)
	
	if (!nt_is_valid_melee(iMeleeId))
	{
		fm_remove_weaponbox(iEnt)
		return
	}
	
	set_pev(iEnt, pev_iuser1, iMeleeId)
	set_pev(iEnt, pev_iuser4, WpnBoxMeleeWait)
	
	new szModelBuffer[256], iSubBody
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_W_MODEL, szModelBuffer, sizeof szModelBuffer - 1)
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_W_SUB, iSubBody)
	
	engfunc(EngFunc_SetModel, iEnt, szModelBuffer)
	set_pev(iEnt, pev_body, iSubBody)
	
	new iRemoveOnDeath
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_REMOVE, iRemoveOnDeath)
	
	if (iRemoveOnDeath && !is_user_alive(iOwner))
	{
		fm_remove_weaponbox(iEnt)
		return
	}
	else	set_task(WEAPONBOX_ACTIVE_TIME, "fw_ActiveMelee", iEnt + TASK_ACTIVE_WEAPONBOX)
	
	
	/*	Give Default Weapon	*/
	nt_set_user_melee(iOwner, -1)
	
	fm_give_item(iOwner, "weapon_knife")
	
	return 
	
}

public fw_ActiveMelee(TASKID)
{
	new iEnt = TASKID - TASK_ACTIVE_WEAPONBOX
	
	if (!pev_valid(iEnt))
		return
		
	set_pev(iEnt, pev_iWpnBoxState, WpnBoxMeleeReady)
}

public fw_emitsound(id, iChannel, const szSample[], Float:fVolume, Float:fATTN, iFlags, iPitch)
{
	
	if (!is_user_connected(id) || !is_user_alive(id))
		return FMRES_IGNORED
	
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return FMRES_IGNORED
		
	if (equal(szSample[8], "kni", 3))
	{
		if (equal(szSample[14], "sla", 3)) // slash
		{
			return FMRES_SUPERCEDE;
		}
		if (equal(szSample[14], "hit", 3))
		{
			if (szSample[17] == 'w') // wall
				return FMRES_SUPERCEDE;
			else // hit
				return FMRES_SUPERCEDE;
		}
		if (equal(szSample[14], "sta", 3)) // stab
		{
			return FMRES_SUPERCEDE;
		}
	}
	
	return FMRES_IGNORED;
}

public fw_CmdStart(id, iUC_HANDLED, SEED)
{
	if (!is_user_alive(id))
		return 
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return
		
	new iWeaponId = get_user_weapon(id)
	
	if (iWeaponId != CSW_KNIFE)
		return
		
	
	new iFirstAttackType
	new iSecondAttackType
	
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_FIRST_ATK_TYPE, iFirstAttackType)
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_SECOND_ATK_TYPE, iSecondAttackType)
	
	new iButton = get_uc(iUC_HANDLED, UC_Buttons)
		
	new iEnt = get_pdata_cbase(id, m_pActiveItem, 5)
	
	if (!pev_valid(iEnt))
		return
	
	new Float:flNextAttack = get_pdata_float(id, m_flNextAttack, 5)
	
	if (flNextAttack > 0.0)
		return
	
	
	if (iButton & IN_ATTACK)
	{
		set_uc(iUC_HANDLED, UC_Buttons, iButton &~IN_ATTACK)			
		engclient_cmd(id, "-attack")
		console_cmd(id, "-attack")
		
		if (iFirstAttackType == 1 || iFirstAttackType == 2)
		{
			
			if (task_exists(id + TASK_KNIFE_FIRST_ATK))
				remove_task(id + TASK_KNIFE_FIRST_ATK)
				
			if (task_exists(id + TASK_KNIFE_SECOND_ATK))
				remove_task(id + TASK_KNIFE_SECOND_ATK)
				
			SetPlayerBit(pBit_DontTrace, id)
			
			ExecuteHamB(Ham_Weapon_PrimaryAttack, iEnt)
			
			if (!CheckPlayerBit(pBit_SecondSeq, id))
			{
				SetPlayerBit(pBit_SecondSeq, id);
				UT_PlayWeaponAnim(id, ANIM_MIDSLASH1)
			}
			else
			{
				ClearPlayerBit(pBit_SecondSeq, id);
				UT_PlayWeaponAnim(id, ANIM_MIDSLASH2)
			}
								
			new szFullSound[128]
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_SLASH, szFullSound, sizeof szFullSound - 1)
			client_cmd(id, "spk %s", szFullSound)
			
			new Float:fAttackTime
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_ATTACK_TIME_1, fAttackTime)
			
			set_pdata_float(id, m_flNextAttack, fAttackTime, 5)
			set_pdata_float(iEnt, m_flNextPrimaryAttack, fAttackTime, 4)
			set_pdata_float(iEnt, m_flNextSecondaryAttack, fAttackTime, 4)
			set_pdata_float(iEnt, m_flTimeWeaponIdle, fAttackTime, 4)
			
			new Float:fDelay
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_DMG_DELAY_1, fDelay)
			set_task(fDelay, "KnifePrimaryAttack_TASK", id + TASK_KNIFE_FIRST_ATK)
			
			ClearPlayerBit(pBit_DontTrace, id)				
							
		}	
	}
	else if (iButton & IN_ATTACK2)
	{
		set_uc(iUC_HANDLED, UC_Buttons, iButton &~IN_ATTACK2)
		engclient_cmd(id, "-attack2")
		console_cmd(id, "-attack2")
		
			
		if (iSecondAttackType == 1 || iSecondAttackType == 2)
		{
			if (task_exists(id + TASK_KNIFE_FIRST_ATK))
				remove_task(id + TASK_KNIFE_FIRST_ATK)
				
			if (task_exists(id + TASK_KNIFE_SECOND_ATK))
				remove_task(id + TASK_KNIFE_SECOND_ATK)
			
			SetPlayerBit(pBit_DontTrace, id)
			
			ExecuteHamB(Ham_Weapon_PrimaryAttack, iEnt)
			
			new Float:fAttackTime
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_ATTACK_TIME_1, fAttackTime)
			
			set_pdata_float(id, m_flNextAttack, fAttackTime, 5)
			set_pdata_float(iEnt, m_flNextPrimaryAttack, fAttackTime, 4)
			set_pdata_float(iEnt, m_flNextSecondaryAttack, fAttackTime, 4)
			set_pdata_float(iEnt, m_flTimeWeaponIdle, fAttackTime, 4)
			
			new Float:fDelay
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_DMG_DELAY_2, fDelay)
			set_task(fDelay, "KnifeSecondaryAttack_TASK", id + TASK_KNIFE_SECOND_ATK)
			
			UT_PlayWeaponAnim(id, ANIM_STAB)
			
			new szFullSound[128]
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_STAB, szFullSound, sizeof szFullSound - 1)
			client_cmd(id, "spk %s", szFullSound)
			ClearPlayerBit(pBit_DontTrace, id)
			
		}	
	}									
	
}

public csred_WpnPostFrame(id, iEnt, iWeaponId)
{	
	if (iWeaponId != CSW_KNIFE)
		return
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return 
		
	if (cs_get_user_shield(id))
	{
		engclient_cmd(id, "drop", "weapon_shield")
		set_pdata_bool(id, m_bHasShield, false, 5)
	}
	new szExtension[32]
	UT_GetWeaponExtension(CSW_KNIFE, cs_get_user_shield(id), szExtension, sizeof szExtension - 1)
	UT_SetPlayerSequence(id, szExtension)
		
}
		
public csred_WpnAttachToPlayerPost(id, iEnt, iWeaponId)
{
	if (iWeaponId != CSW_KNIFE)
		return
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
	{
		UT_UpdateWpnList(id, CSW_KNIFE, 1, "weapon_knife", 0, 0)
		return
	}
	
	new szWeaponClass[128]
	
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_CLASS, szWeaponClass, sizeof szWeaponClass - 1)
	UT_UpdateWpnList(id, CSW_KNIFE, 1, szWeaponClass, 0, 0)
}

public KnifePrimaryAttack_TASK(TASKID)
{
	new id = TASKID - TASK_KNIFE_FIRST_ATK
	
	if (!is_user_alive(id))
		return
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return
		
	
		
	new szWeaponHud[128]
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_HUD, szWeaponHud, sizeof szWeaponHud - 1)
	
	
	new iFirstAttackType
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_FIRST_ATK_TYPE, iFirstAttackType)
	
	switch (iFirstAttackType)
	{
		case 1:
		{
			new Float:fDamage, Float:fRange, iDamageBit
			
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DAMAGE_1, fDamage)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_RANGE_1, fRange)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DMGBIT_1, iDamageBit)
			
			new szWallSound[128], szBodySound[128]
			
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITWALL, szWallSound, sizeof szWallSound - 1)
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITBODY, szBodySound, sizeof szBodySound - 1)
			
			UT_MeleeAttack(id, 1,  fDamage, fRange, iDamageBit, 1, szWallSound, szBodySound)
		}
		case 2:
		{
			new Float:fDamage, Float:fRange, iDamageBit
			
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DAMAGE_2, fDamage)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_RANGE_2, fRange)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DMGBIT_2, iDamageBit)
			
			new szWallSound[128], szBodySound[128]
			
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITWALL, szWallSound, sizeof szWallSound - 1)
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITBODY, szBodySound, sizeof szBodySound - 1)
			
			UT_MeleeAttack(id, 0,  fDamage, fRange, iDamageBit, 1, szWallSound, szBodySound)
		}
	}
}

public KnifeSecondaryAttack_TASK(TASKID)
{
	new id = TASKID - TASK_KNIFE_SECOND_ATK
	
	if (!is_user_alive(id))
		return
	
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return
		
	new szWeaponHud[128]
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_WEAPON_HUD, szWeaponHud, sizeof szWeaponHud - 1)
	
	new iSecondAttackType
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_SECOND_ATK_TYPE, iSecondAttackType)
	
	switch (iSecondAttackType)
	{
		case 1:
		{
			new Float:fDamage, Float:fRange, iDamageBit
			
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DAMAGE_2, fDamage)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_RANGE_2, fRange)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DMGBIT_2, iDamageBit)
			
			new szWallSound[128], szBodySound[128]
			
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITWALL, szWallSound, sizeof szWallSound - 1)
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITBODY, szBodySound, sizeof szBodySound - 1)
			
			UT_MeleeAttack(id, 1,  fDamage, fRange, iDamageBit, 1, szWallSound, szBodySound)
			
		}
		case 2:
		{
			new Float:fDamage, Float:fRange, iDamageBit
			
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DAMAGE_2, fDamage)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_RANGE_2, fRange)
			TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DMGBIT_2, iDamageBit)
			
			new szWallSound[128], szBodySound[128]
			
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITWALL, szWallSound, sizeof szWallSound - 1)
			TrieGetString(weapon_StringInfo[iMeleeId], SECTION_SOUND_HITBODY, szBodySound, sizeof szBodySound - 1)
			
			UT_MeleeAttack(id, 0,  fDamage, fRange, iDamageBit, 1, szWallSound, szBodySound)
		}
	}
}


public fw_WpnBoxTouch(iEnt, id)
{
	if (!is_user_alive(id))
		return PLUGIN_CONTINUE
		
	if (!pev_valid(iEnt))
		return PLUGIN_HANDLED
	
	if (!IsWeaponBoxCanTouch(iEnt))	
		return PLUGIN_HANDLED
		
	if (!IsCsRedWpnBox(iEnt))
		return PLUGIN_CONTINUE

	
	if (cs_get_user_shield(id))
		return PLUGIN_HANDLED
		
	new iState = pev(iEnt, pev_iuser4)
	
	if (iState == WpnBoxMeleeReady)
	{
		if (!can_player_touch_wpnbox(id))
			return PLUGIN_HANDLED
			
		new iMeleeId = nt_get_user_melee(id)
		
		if (nt_is_valid_melee(iMeleeId) && user_has_weapon(id, CSW_KNIFE))
			return PLUGIN_HANDLED
		
		nt_give_user_melee(id, pev(iEnt, pev_iuser1))
		fm_remove_weaponbox(iEnt)
	}
	return PLUGIN_HANDLED
	
}

public fw_ArmouryTouched(iEnt, id)
{
	if (!is_user_alive(id))
		return PLUGIN_CONTINUE
			
	if (!pev_valid(iEnt))
		return PLUGIN_CONTINUE
		
	new iArmouryId = pev(iEnt, pev_ArmouryId)
	new iArmouryType = pev(iEnt, pev_ArmouryType)
	new iArmouryState = pev(iEnt, pev_ArmouryStatus)
	//new iArmouryWpnType = pev(iEnt, pev_ArmouryWpnType)
	
	if (iArmouryType != ARMOURY_MELEE)
		return PLUGIN_CONTINUE
		
	if (iArmouryState == ARMOURY_DISABLED)
		return PLUGIN_HANDLED
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (iMeleeId > -1)
		return PLUGIN_HANDLED
	
	if (cs_get_user_shield(id))
		return PLUGIN_HANDLED
	
	if (!can_player_touch_armoury(id))
		return PLUGIN_HANDLED
		
	nt_give_user_melee(id, iArmouryId)
	
	engfunc(EngFunc_RemoveEntity, iEnt)
	
	ExecuteForward(ifw_ArmouryPickedUp, ifw_Result, id, iEnt)
	
	return PLUGIN_HANDLED
	
}

public fw_MeleePrimaryAttack(iEnt)
	return HAM_SUPERCEDE
	
public csred_WpnDeploy_Pre(id, iEnt, iWeaponId)
{
	if (!is_user_alive(id))
	{
		if (iWeaponId == CSW_KNIFE)
			return PLUGIN_HANDLED
			
		return PLUGIN_CONTINUE
	}
	remove_task(id + TASK_KNIFE_FIRST_ATK)		
	remove_task(id + TASK_KNIFE_SECOND_ATK)
		
	if (iWeaponId != CSW_KNIFE)
		return PLUGIN_CONTINUE
		
	new iMeleeId = nt_get_user_melee(id)
	
	set_pdata_int(id, m_bHasShield, 0, 5)
	set_pev(id, pev_gamestate, 1)
	
	if (!nt_is_valid_melee(iMeleeId))
	{
		UT_CS_Crosshair_Toggle(id, 0, 1)
		DefaultDeploy(id, iEnt, iWeaponId)
		return PLUGIN_HANDLED
	}
	
	ClearPlayerBit(pBit_SecondSeq, id);
	
	new Float:fDeployTime
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_WPN_DEPLOY_TIME, fDeployTime)
	
	set_pdata_float(id, m_flNextAttack, fDeployTime, 5)
	set_pdata_float(iEnt, m_flNextPrimaryAttack, fDeployTime, 4)
	set_pdata_float(iEnt, m_flNextSecondaryAttack, fDeployTime, 4)
	set_pdata_float(iEnt, m_flTimeWeaponIdle, fDeployTime, 4)
	
	UT_PlayWeaponAnim(id, ANIM_DRAW)
	
	new szModelBuffer[256], iSubBody
				
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_V_MODEL, szModelBuffer, sizeof szModelBuffer - 1)
	set_pev(id, pev_viewmodel2, szModelBuffer)
	
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_V_SUB, iSubBody)
	MMCL_SetViewEntityBody(id, iSubBody)
	
	TrieGetString(weapon_StringInfo[iMeleeId], SECTION_P_MODEL, szModelBuffer, sizeof szModelBuffer - 1)
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_P_SUB, iSubBody)
	set_pev(id, pev_weaponmodel2, "")
	
	engfunc(EngFunc_SetModel, iEnt, szModelBuffer)
	set_pev(id, pev_body, iSubBody)
	fm_set_entity_visibility(iEnt, 1)
	
	new szExtension[32]
	UT_GetWeaponExtension(CSW_KNIFE, cs_get_user_shield(id), szExtension, sizeof szExtension - 1)
	UT_SetPlayerSequence(id, szExtension)
	
	return PLUGIN_HANDLED
}

public csred_WpnHolster_Post(id, iEnt)
{
	if (!pev_valid(iEnt))
		return
		
	new iWeaponId = cs_get_weapon_id(iEnt)
	
	if (iWeaponId != CSW_KNIFE)
		return
	
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
	{
		fm_set_entity_visibility(iEnt, 0)
		return
	}
	
	remove_task(id + TASK_KNIFE_FIRST_ATK)		
	remove_task(id + TASK_KNIFE_SECOND_ATK)
	
	new iSubBody
	TrieGetCell(weapon_StringInfo[iMeleeId], SECTION_BACK_MODEL, iSubBody)
	
	if (iSubBody > -1)
	{
		new szBackModel[128]
		TrieGetString(weapon_StringInfo[iMeleeId], SECTION_BACK_MODEL, szBackModel, sizeof szBackModel - 1)
		engfunc(EngFunc_SetModel, iEnt, szBackModel)
		set_pev(iEnt, pev_body, iSubBody)
		fm_set_entity_visibility(iEnt, 1)
	
	}
	else
		fm_set_entity_visibility(iEnt, 0)
}

public TFM_RemovePlayItem_Pre(id, iEnt, iWeaponId)
{
	if (!pev_valid(iEnt))
		return
		
	remove_task(id + TASK_KNIFE_FIRST_ATK)		
	remove_task(id + TASK_KNIFE_SECOND_ATK)
	fm_set_entity_visibility(iEnt, 0)
}

public csred_ItemDrop_Pre(id, iEnt, iWeaponId)
{
	if (!pev_valid(iEnt))
		return PLUGIN_CONTINUE
		
	if (iWeaponId != CSW_KNIFE)
		return PLUGIN_CONTINUE
		
	if (!is_user_connected(id))
		return PLUGIN_CONTINUE
		
	new iMeleeId = nt_get_user_melee(id)
	
	if (!nt_is_valid_melee(iMeleeId))
		return PLUGIN_CONTINUE
		
	return PLUGIN_HANDLED
	
}

stock str_count(const str[], searchchar)
{
	new count, i
	//count = 0
	
	for (i = 0; i <= strlen(str); i++)
	{
		if(str[i] == searchchar)
			count++
	}
	
	return count;
}

stock load_melee_file(szDirectory[], szFileName[], szExtension[], iIgnore_AllConditions)
{
	if (!iPrecachedModel)
		iPrecachedModel = TrieCreate()
		
	new szCfgDir[128]
	new szMapName[32]
	new szLoadingFile[256]
	
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	get_mapname(szMapName, sizeof szMapName - 1)
	
	formatex(szLoadingFile, sizeof szLoadingFile - 1, "%s/%s/%s.%s", szCfgDir, szDirectory, szFileName, szExtension)
	
	if (!file_exists(szLoadingFile))
		return
		
	if (g_weapon_count > max_wpn - 1)
		return 
		
	if (TrieKeyExists(iLoadedFile, szFileName))
		return
		
	new szText[128], iTextLen
	
	read_file(szLoadingFile, LINE_WPN_SERIAL, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[iSerial]", "")
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_SERIAL, szText)
	if (!iIgnore_AllConditions)
	{
		ExecuteForward(ifw_MeleeCheckSerial, ifw_Result, szText)
		
		if (ifw_Result != PLUGIN_CONTINUE)
			return 
	}
	read_file(szLoadingFile, LINE_WPN_NAME, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_NAME]", "")
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_NAME, szText)
	
	read_file(szLoadingFile, LINE_WPN_ATTACK_TYPE, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[ATK_TYPE]", "")
	
	new szFirstType[10], szSecondType[10]
	
	parse(szText, szFirstType, sizeof szFirstType - 1, szSecondType, sizeof szSecondType - 1)
	
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_FIRST_ATK_TYPE, str_to_num(szFirstType))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_SECOND_ATK_TYPE,  str_to_num(szSecondType))
	
	read_file(szLoadingFile, LINE_WPN_RANGE, szText, sizeof szText - 1, iTextLen)
	replace(szText, 127, "[WPN_RANGE]", "")
	
	new szFirstRange[10], szSecondRange[10]
	
	parse(szText, szFirstRange, sizeof szFirstRange - 1, szSecondRange, sizeof szSecondRange - 1)
	
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_RANGE_1,  str_to_float(szFirstRange))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_RANGE_2, str_to_float(szSecondRange))
	
	read_file(szLoadingFile, LINE_WPN_ATK_TIME, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[ATK_TIME]", "")
	
	new szFirstATK_Time[10], szSecondATK_Time[10]
	
	parse(szText, szFirstATK_Time, sizeof szFirstATK_Time - 1, szSecondATK_Time, sizeof szSecondATK_Time)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_ATTACK_TIME_1, str_to_float(szFirstATK_Time))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_ATTACK_TIME_2, str_to_float(szSecondATK_Time))
	
	read_file(szLoadingFile, LINE_WPN_DELAY, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_DELAY]", "")
	new szFirstDelay[10], szSecondDelay[10]
	parse(szText, szFirstDelay, sizeof szFirstDelay - 1, szSecondDelay, sizeof szSecondDelay - 1)
	
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_DMG_DELAY_1,  str_to_float(szFirstDelay))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_DMG_DELAY_2, str_to_float(szSecondDelay))
	
	read_file(szLoadingFile, LINE_WPN_HUD, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_HUD]", "")
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_HUD, szText)
	
	read_file(szLoadingFile, LINE_WPN_DMG, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_DMG]", "")
	new szFirstDamage[10], szSecondDamage[10], szFirstDmgBit[10], szSecondDmgBit[10]
	parse(szText, szFirstDamage, sizeof szFirstDamage - 1, szSecondDamage, sizeof szSecondDamage - 1,
		szFirstDmgBit, sizeof szFirstDmgBit - 1 ,szSecondDmgBit, sizeof szSecondDmgBit - 1)
		
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_DAMAGE_1, str_to_float(szFirstDamage))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_DAMAGE_2,  str_to_float(szSecondDamage))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_DMGBIT_1, read_flags(szFirstDmgBit))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_DMGBIT_2, read_flags(szSecondDmgBit))
	
	read_file(szLoadingFile, LINE_WPN_COST, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_COST]", "")
	new szCost[10], szCostType[10], szLevel[10]
	parse(szText, szCost, sizeof szCost - 1, szCostType , sizeof szCostType - 1, szLevel, sizeof szLevel - 1)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_COST, str_to_num(szCost))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_COST_TYPE, str_to_num(szCostType))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_LEVEL, str_to_num(szLevel))
	
	
	new szBuffer[250], szSubBody[3]
	
	read_file(szLoadingFile, LINE_W_MODEL, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[W_MODEL]", "")
	parse(szText, szBuffer, sizeof szBuffer - 1, szSubBody, sizeof szSubBody - 1)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_W_MODEL, szBuffer)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_W_SUB, str_to_num(szSubBody))
	
	if (!TrieKeyExists(iPrecachedModel, szBuffer))
	{
		engfunc(EngFunc_PrecacheModel, szBuffer)
		TrieSetCell(iPrecachedModel, szBuffer, 1)
	}
	
	read_file(szLoadingFile, LINE_P_MODEL, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[P_MODEL]", "")
	parse(szText, szBuffer, sizeof szBuffer - 1, szSubBody, sizeof szSubBody - 1)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_P_MODEL, szBuffer)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_P_SUB, str_to_num(szSubBody))
	
	if (!TrieKeyExists(iPrecachedModel, szBuffer))
	{
		engfunc(EngFunc_PrecacheModel, szBuffer)
		TrieSetCell(iPrecachedModel, szBuffer, 1)
	}
	
	read_file(szLoadingFile, LINE_V_MODEL, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[V_MODEL]", "")
	parse(szText, szBuffer, sizeof szBuffer - 1, szSubBody, sizeof szSubBody - 1)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_V_MODEL, szBuffer)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_V_SUB, str_to_num(szSubBody))
	
	if (!TrieKeyExists(iPrecachedModel, szBuffer))
	{
		engfunc(EngFunc_PrecacheModel, szBuffer)
		TrieSetCell(iPrecachedModel, szBuffer, 1)
	}
	
	read_file(szLoadingFile, LINE_WPN_SOUND, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_SOUND]", "")
	
	new szFullSound[128]
	
	//	HITBODY SOUND
	formatex(szFullSound, sizeof szFullSound - 1, "weapons/%s/%s-HITBODY.wav", SOUND_DIRECTORY, szText)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_SOUND_HITBODY, szFullSound)
	//	HITWALL SOUND
	formatex(szFullSound, sizeof szFullSound - 1, "weapons/%s/%s-HITWALL.wav", SOUND_DIRECTORY, szText)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_SOUND_HITWALL, szFullSound)
	//	SLASH SOUND
	formatex(szFullSound, sizeof szFullSound - 1, "weapons/%s/%s-SLASH.wav", SOUND_DIRECTORY, szText)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_SOUND_SLASH, szFullSound)
	//	STAB SOUND
	formatex(szFullSound, sizeof szFullSound - 1, "weapons/%s/%s-STAB.wav", SOUND_DIRECTORY, szText)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_SOUND_STAB, szFullSound)
	
	read_file(szLoadingFile, LINE_WPN_DEPLOY_TIME, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_DeployTime]", "")
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_DEPLOY_TIME, str_to_float(szText))
	
	read_file(szLoadingFile, LINE_WPN_WEIGHT, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_WEIGHT]", "")
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_WEIGTH, str_to_float(szText))
	
	read_file(szLoadingFile, LINE_WPN_SPEED, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_SPEED]", "")
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_SPEED_REDUCTION, str_to_float(szText))
	
	read_file(szLoadingFile, LINE_WPN_KNOCKBACK, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText- 1, "[WPN_KB]", "")
	new szKnockBackPower[32], szKnockBackDistance[32]
	parse(szText, szKnockBackPower, sizeof szKnockBackPower - 1, szKnockBackDistance, sizeof szKnockBackDistance - 1)
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_KNOCKBACK_POWER, str_to_float(szKnockBackPower))
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_KNOCKBACK_DISTANCE, str_to_num(szKnockBackDistance))
	
	read_file(szLoadingFile, LINE_WPN_REMOVE, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_REMOVE]", "")
	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_WPN_REMOVE, str_to_num(szText))
	
	read_file(szLoadingFile, LINE_WPN_CLASS, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[WPN_CLASS]", "")
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_CLASS, szText)
	register_clcmd(szText, "clcmd_select_weapon")
	
	read_file(szLoadingFile, LINE_WPN_BACKWPN, szText, sizeof szText - 1, iTextLen)
	replace(szText, sizeof szText - 1, "[BACK_WPN]", "")
	new szToggle[3]
	parse(szText, szToggle, sizeof szToggle - 1, szBuffer, sizeof szBuffer - 1, szSubBody, sizeof szSubBody - 1)
	
	if (str_to_num(szToggle))
	{
		if (!TrieKeyExists(iPrecachedModel, szBuffer))
		{
			engfunc(EngFunc_PrecacheModel, szBuffer)
			TrieSetCell(iPrecachedModel, szBuffer, 1)
		}
		
		TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_BACK_MODEL, szBuffer)
		TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_BACK_MODEL, str_to_num(szSubBody))
	}
	else	TrieSetCell(weapon_StringInfo[g_weapon_count], SECTION_BACK_MODEL, -1)
	

	read_file(szLoadingFile, LINE_WPN_SEQ, szText, sizeof szText - 1, iTextLen)
	
	replace(szText, sizeof szText - 1, "[WPN_SEQ]", "")
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_SEQ, szText)
	
	new cInfo[32]
	formatex(cInfo, sizeof cInfo - 1, "%d", g_weapon_count) 
		
	new szWeaponName[128]
	TrieGetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_NAME, szWeaponName, sizeof szWeaponName - 1)
	
		
	menu_additem(iArmouryMenuId , szWeaponName, cInfo, ADMIN_MENU)		
	TrieSetCell(iLoadedFile, szFileName, 1)
	
	new szSpawnFile[256]
	formatex(szSpawnFile, sizeof szSpawnFile - 1, "%s/%s/%s/%s.cfg", szCfgDir, WPN_SPAWN_DIR, szMapName, szFileName)
	TrieSetString(weapon_StringInfo[g_weapon_count], SECTION_WEAPON_SPAWN_FILE, szSpawnFile)
		
			
	if (file_exists(szSpawnFile))
	{
		for (new i = 0; i < file_size(szSpawnFile, 1); i++)
		{
			if (iTotalSpawnPoint > MAX_SPAWN_POINT - 1)
				continue
				
			read_file(szSpawnFile, i, szText, sizeof szText - 1, iTextLen)
			
			new cOrigin[3][10]
			
			parse(szText, cOrigin[0], 9, cOrigin[1], 9, cOrigin[2], 9)
			
			fSpawnVecs[iTotalSpawnPoint][0] = str_to_float(cOrigin[0])
			fSpawnVecs[iTotalSpawnPoint][1] = str_to_float(cOrigin[1])
			fSpawnVecs[iTotalSpawnPoint][2] = str_to_float(cOrigin[2])
			iSpawnWeaponId[iTotalSpawnPoint] = g_weapon_count
			
			iTotalSpawnPoint++
		}
	}
	
	new iLoadedId = g_weapon_count
	g_weapon_count++
	
	ExecuteForward(ifw_WeaponLoaded, ifw_Result, iLoadedId)
}

stock IsValidWeapon(iWeaponId)
{
	if (iWeaponId < 1 || iWeaponId > CSW_P90 || iWeaponId == 2)
		return 0
		
	return 1
}

stock CreateArmoury(iPoint, iMeleeId, Float:fOrigin[3])
{
	
	ExecuteForward(ifw_ArmouryEntitySpawn, ifw_Result, iMeleeId)
	
	if (ifw_Result != PLUGIN_CONTINUE)
		return
		
	new iEnt = fm_create_entity("armoury_entity")
	
	if (!iEnt)
		return
	
	
	dllfunc( DLLFunc_Spawn, iEnt );
	
	new iWeaponId 
	
	
	if (!nt_is_valid_melee(iMeleeId))
	{
		iWeaponId = iSpawnWeaponId[iPoint]
		set_pev(iEnt, pev_origin, fSpawnVecs[iPoint])
	}
	else
	{
		iWeaponId = iMeleeId
		set_pev(iEnt, pev_origin, fOrigin)
	}

	set_pev(iEnt, pev_mins, {-3.0, -3.0, -3.0})
	set_pev(iEnt, pev_maxs, {3.0, 3.0, 3.0})
	
	set_pev(iEnt, pev_ArmouryId, iWeaponId)
	set_pev(iEnt, pev_ArmouryType, ARMOURY_MELEE)
	set_pev(iEnt, pev_ArmouryStatus, ARMOURY_ENABLED)
	
	new szModelBuffer[256], iSubBody
		
	TrieGetString(weapon_StringInfo[iWeaponId], SECTION_W_MODEL, szModelBuffer, sizeof szModelBuffer - 1)
	engfunc(EngFunc_SetModel, iEnt, szModelBuffer)
	TrieGetCell(weapon_StringInfo[iWeaponId], SECTION_W_SUB, iSubBody)
	set_pev(iEnt, pev_body, iSubBody)
	set_pev(iEnt, pev_ArmouryPoint, iPoint)
	
}

stock _find_melee_by_model(szModel[])
{
	for (new i = 0; i < g_weapon_count; i++)
	{
		new szViewModel[128]
		TrieGetString(weapon_StringInfo[i], SECTION_V_MODEL, szViewModel, sizeof szViewModel - 1)
		
		if (equal(szModel, szViewModel))
			return i
	}
	return -1
}

stock can_player_equip_melee(id)
{
	ExecuteForward(ifw_UserCanEquipWpn, ifw_Result, id)
	
	if (ifw_Result != PLUGIN_CONTINUE)
		return 0
		
	return 1
}

stock can_player_touch_armoury(id)
{
	ExecuteForward(ifw_UserCanTouchArmoury, ifw_Result, id)
	
	if (ifw_Result !=  PLUGIN_CONTINUE)
		return 0
		
	return 1
}

stock can_player_touch_wpnbox(id)
{
	ExecuteForward(ifw_UserCanTouchWpnBox, ifw_Result, id)
	
	if (ifw_Result != PLUGIN_CONTINUE)
		return 0
		
	return 1
}


stock draw_deathmsg(iKiller, iVictim, iHeadshot, szWeapon[])
{
	emessage_begin(MSG_ALL, iMSGID_DeathMsg, {0,0,0}, 0);
	ewrite_byte(iKiller);
	ewrite_byte(iVictim);

	new szModName[32];
	get_modname(szModName, sizeof szModName - 1);
	if (equal(szModName, "cstrike") || equal(szModName, "czero") || equal(szModName, "csv15") || equal(szModName, "cs13"))
		ewrite_byte(iHeadshot);
	ewrite_string(szWeapon);
	emessage_end();

	return 1;
}


stock forward_register()
{
	ifw_MeleeCheckSerial = CreateMultiForward("MM_MeleeCheckSerial", ET_CONTINUE, FP_STRING)
	ifw_ArmouryPickedUp = CreateMultiForward("MM_ArmouryPickedUp", ET_IGNORE, FP_CELL, FP_CELL)
	
	ifw_UserCanTouchWpnBox = CreateMultiForward("MM_UserCanTouchWpnBox", ET_CONTINUE, FP_CELL)
	ifw_UserCanTouchArmoury = CreateMultiForward("MM_UserCanTouchArmoury", ET_CONTINUE, FP_CELL)
	ifw_UserCanEquipWpn = CreateMultiForward("MM_UserCanEquipMelee", ET_CONTINUE, FP_CELL)
	ifw_ArmouryEntitySpawn = CreateMultiForward("MM_ArmouryEntitySpawn", ET_CONTINUE, FP_CELL)
	
	ifw_WeaponLoaded = CreateMultiForward("MM_WeaponLoaded", ET_IGNORE, FP_CELL)
	
}


/*************************************************************************************/

stock get_cs_weapon_model(iWeaponId, szOutput[], iLen)
{
	if (iWeaponId != CSW_KNIFE)
		return 0
		
	formatex(szOutput, iLen, MELEE_MDL)	
	return 1
}

stock get_cs_replace_model(iWeaponId, szOutput[], iLen)
{
	if (iWeaponId != CSW_KNIFE)
		return 0
		
	formatex(szOutput, iLen, MELEE_REPLACE_MDL)
	return 1
}

stock get_cs_v_mdl_subbody(iWeaponId)
{	
	if (iWeaponId == CSW_KNIFE)
		return MELEE_V_REPLACE_BODY
	
	return 0
}

stock get_cs_p_mdl_subbody(iWeaponId)
{
	if (iWeaponId == CSW_KNIFE)
		return MELEE_P_REPLACE_BODY
	
	return 0
}

stock get_cs_w_mdl_subbody(iWeaponId)
{
	if (iWeaponId == CSW_KNIFE)
		return MELEE_W_REPLACE_BODY
	
	return 0
}

stock DefaultDeploy(id, iEnt, iWeaponId)
{	
	new szCsModel[32]
	new szWeaponModel[128]
	
	UT_Get_CS_WpnModel(iWeaponId, szCsModel, sizeof szCsModel - 1)
	
	if (strlen(szCsModel) > 0)
	{
		formatex(szWeaponModel, sizeof szWeaponModel - 1, "models/v_%s.mdl", szCsModel)
		set_pev(id, pev_viewmodel2, "models/v_knife.mdl")
		MMCL_SetViewEntityBody(id, 0)
		set_pev(id, pev_weaponmodel2, "")
		
		set_pev(iEnt, pev_body, 0)
		formatex(szWeaponModel, sizeof szWeaponModel - 1, "models/p_%s.mdl", szCsModel)
		engfunc(EngFunc_SetModel, iEnt, szWeaponModel)
		fm_set_entity_visibility(iEnt, 1)
	}
	
	
	
	new iShield = cs_get_user_shield(id)
	new iSilen = cs_get_weapon_silen(iEnt)
	
	new szAnimExtension[32]
	UT_GetWeaponExtension(iWeaponId, iShield, szAnimExtension, sizeof szAnimExtension - 1)
	UT_SetPlayerSequence(id, szAnimExtension)
	
	new iDrawAnimation = Get_CSWPN_Anim_Draw(iWeaponId, iSilen, iShield)
	UT_PlayWeaponAnim(id, iDrawAnimation)

	set_pdata_float(id, m_flNextAttack, 0.75, 5)
	set_pdata_float(iEnt, m_flTimeWeaponIdle, 1.5, 4)
	set_pdata_float(iEnt, m_flDecreaseShotsFired, get_gametime(), 4)
	
	set_pdata_int(id, m_iFOV, 90, 5)
	set_pdata_bool(id, m_fResumeZoom, false, 5)
	set_pdata_int(id, m_iLastZoom, 90, 5)
	
}

