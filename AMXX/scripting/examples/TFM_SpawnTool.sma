/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta>

#define PLUGIN "[Do Random Spawn]"
#define VERSION "1.0"
#define AUTHOR "Nguyen Duy Linh"

#define SPAWN_DATA_ORIGIN_X	"ORIGIN_X"
#define SPAWN_DATA_ORIGIN_Y	"ORIGIN_Y"
#define SPAWN_DATA_ORIGIN_Z	"ORIGIN_Z"

#define SPAWN_DATA_ANGLES_X	"ANGLE_X"
#define SPAWN_DATA_ANGLES_Y	"ANGLE_Y"
#define SPAWN_DATA_ANGLES_Z	"ANGLE_Z"

#define SPAWN_DATA_V_ANGLES_X	"V_ANGLE_X"
#define SPAWN_DATA_V_ANGLES_Y	"V_ANGLE_Y"
#define SPAWN_DATA_V_ANGLES_Z	"V_ANGLE_Z"

new Trie:iSpawnInfo
new Trie:iOriginalSpawnInfo

new g_SpawnCountCSDM
new g_SpawnCountRegular

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, VERSION)
	
	if (!iSpawnInfo)
		iSpawnInfo = TrieCreate()
	
	if (!iOriginalSpawnInfo)
		iOriginalSpawnInfo = TrieCreate()
		
	load_spawns()
}


public plugin_natives()
{
	register_native("csred_DoRandomSpawn", "native_random_spawn_do", 1)
	register_native("csred_CSDM_SpawnNumber", "native_CSDM_SpawnNumber", 1)
	register_native("csred_Regular_SpawnNumber", "native_Regular_SpawnNumber", 1)
}

//	NATIVE

public native_random_spawn_do(id, iCSDM_SpawnType)
{
	if (!is_user_alive(id))
		return
	do_random_spawn(id, iCSDM_SpawnType)
}

public native_CSDM_SpawnNumber()
	return g_SpawnCountCSDM

public native_Regular_SpawnNumber()
	return g_SpawnCountRegular

// Place user at a random spawn
stock do_random_spawn(id, csdmspawns)
{
	new hull, spawn_index, current_index
	
	// Get whether the player is crouching
	hull = (pev(id, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN
	
	// Use CSDM spawns?
	if (csdmspawns)
	{
		if(g_SpawnCountCSDM)
		{
			// Choose random spawn to start looping at
			spawn_index = random_num(0, g_SpawnCountCSDM - 1)
			
			new szKey[128]
			
			// Try to find a clear spawn
			for (current_index = spawn_index + 1; /*no condition*/; current_index++)
			{
				// Start over when we reach the end
				if (current_index >= g_SpawnCountCSDM) 
					current_index = 0
				
				// Fetch spawn data: origin
				new Float:spawndata[3]
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_X, current_index) 
				spawndata[0] = get_float_from_key(iSpawnInfo, szKey)
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Y, current_index) 
				spawndata[1] = get_float_from_key(iSpawnInfo, szKey)
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Z, current_index) 
				spawndata[2] = get_float_from_key(iSpawnInfo, szKey)
				
				// Free spawn space?
				if (is_hull_vacant(spawndata, hull))
				{
					// Engfunc_SetOrigin is used so ent's mins and maxs get updated instantly
					engfunc(EngFunc_SetOrigin, id, spawndata)
					
					// Fetch spawn data: angles
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_X, current_index) 
					spawndata[0] = get_float_from_key(iSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Y, current_index) 
					spawndata[1] = get_float_from_key(iSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Z, current_index) 
					spawndata[2] = get_float_from_key(iSpawnInfo, szKey)
					
					set_pev(id, pev_angles, spawndata)
					
					// Fetch spawn data: view angles
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_X, current_index) 
					spawndata[0] = get_float_from_key(iSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Y, current_index) 
					spawndata[1] = get_float_from_key(iSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Z, current_index) 
					spawndata[2] = get_float_from_key(iSpawnInfo, szKey)
					
					set_pev(id, pev_v_angle, spawndata)
					
					break;
				}
				
				// Loop completed, no free space found
				if (current_index == spawn_index) 
					break;
			}
		}
	}
	else 
	{
		if (g_SpawnCountRegular)
		{
			// Choose random spawn to start looping at
			spawn_index = random_num(0, g_SpawnCountRegular - 1)
			new szKey[128]
			
			// Try to find a clear spawn
			for (current_index = spawn_index + 1; /*no condition*/; current_index++)
			{
				// Start over when we reach the end
				if (current_index >= g_SpawnCountCSDM) 
					current_index = 0
				
				// Fetch spawn data: origin
				new Float:spawndata[3]
				
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_X, current_index) 
				spawndata[0] = get_float_from_key(iOriginalSpawnInfo, szKey)
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Y, current_index) 
				spawndata[1] = get_float_from_key(iOriginalSpawnInfo, szKey)
				
				formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Z, current_index) 
				spawndata[2] = get_float_from_key(iOriginalSpawnInfo, szKey)
				
				// Free spawn space?
				if (is_hull_vacant(spawndata, hull))
				{
					// Engfunc_SetOrigin is used so ent's mins and maxs get updated instantly
					engfunc(EngFunc_SetOrigin, id, spawndata)
					
					// Fetch spawn data: angles
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_X, current_index) 
					spawndata[0] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Y, current_index) 
					spawndata[1] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Z, current_index) 
					spawndata[2] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					set_pev(id, pev_angles, spawndata)
					
					// Fetch spawn data: view angles
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_X, current_index) 
					spawndata[0] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Y, current_index) 
					spawndata[1] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Z, current_index) 
					spawndata[2] = get_float_from_key(iOriginalSpawnInfo, szKey)
					
					set_pev(id, pev_v_angle, spawndata)
					
					break;
				}
				
				// Loop completed, no free space found
				if (current_index == spawn_index) 
					break;
			}
		}
	}
}

// Checks if a space is vacant (credits to VEN)
stock is_hull_vacant(Float:origin[3], hull)
{
	engfunc(EngFunc_TraceHull, origin, origin, 0, hull, 0, 0)
	
	if (!get_tr2(0, TR_StartSolid) && !get_tr2(0, TR_AllSolid) && get_tr2(0, TR_InOpen))
		return true;
	
	return false;
}


// Collect random spawn points
stock load_spawns()
{
	// Check for CSDM spawns of the current map
	new cfgdir[32], mapname[32], filepath[100], linedata[64]
	get_configsdir(cfgdir, charsmax(cfgdir))
	get_mapname(mapname, charsmax(mapname))
	formatex(filepath, charsmax(filepath), "%s/csdm/%s.spawns.cfg", cfgdir, mapname)
	new szKey[128]
	
	// Load CSDM spawns if present
	if (file_exists(filepath))
	{
		new csdmdata[10][6], file = fopen(filepath,"rt")
		
		while (file && !feof(file))
		{
			
				
			fgets(file, linedata, charsmax(linedata))
			
			// invalid spawn
			if(!linedata[0] || str_count(linedata,' ') < 2) continue;
			
			// get spawn point data
			parse(linedata,csdmdata[0],5,csdmdata[1],5,csdmdata[2],5,csdmdata[3],5,csdmdata[4],5,csdmdata[5],5,csdmdata[6],5,csdmdata[7],5,csdmdata[8],5,csdmdata[9],5)
			
			// origin
			
		
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_X, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[0]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Y, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[1]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Z, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[2]))
			
			
			// angles
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_X, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[3]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Y, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[4]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Z, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[5]))
			
			// view angles
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_X, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[7]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Y, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[8]))
			
			formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Z, g_SpawnCountCSDM) 
			set_float_to_key(iSpawnInfo, szKey, str_to_float(csdmdata[9]))
			
			
			
			// increase spawn count
			g_SpawnCountCSDM++
			
		}
		if (file) fclose(file)
	
		// Collect regular spawns
		collect_spawns_ent("info_player_start")
		collect_spawns_ent("info_player_deathmatch")
	}
}

// Collect spawn points from entity origins
stock collect_spawns_ent(const classname[])
{
	new Float:data[3]
	new ent = -1
	new szKey[128]
	
	while ((ent = engfunc(EngFunc_FindEntityByString, ent, "classname", classname)) != 0)
	{
		
			
		// get origin
		pev(ent, pev_origin, data)
		
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_X, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[0])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Y, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[1])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ORIGIN_Z, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[2])
			
			
		// angles
		pev(ent, pev_angles, data)
		
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_X, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[0])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Y, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[1])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_ANGLES_Z, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[2])
		
		
		// view angles
		pev(ent, pev_v_angle, data)
		
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_X, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[0])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Y, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[1])
			
		formatex(szKey, sizeof szKey - 1, "%s_%d", SPAWN_DATA_V_ANGLES_Z, g_SpawnCountCSDM) 
		set_float_to_key(iOriginalSpawnInfo, szKey, data[2])
		
		// increase spawn count
		g_SpawnCountRegular++
		
	}
}

// Stock by (probably) Twilight Suzuka -counts number of chars in a string
stock str_count(const str[], searchchar)
{
	new count, i, len = strlen(str)
	
	for (i = 0; i <= len; i++)
	{
		if(str[i] == searchchar)
			count++
	}
	
	return count;
}

stock set_float_to_key(Trie:iTrie, szKey[], Float:fInput)
{
	if (!iTrie)
		return
		
	TrieSetCell(iTrie, szKey, fInput)
}

stock Float:get_float_from_key(Trie:iTrie, szKey[])
{
	
	if (!iTrie)
		return 0.0
	
	new Float:fOutput
	TrieGetCell(iTrie, szKey, fOutput)
	return fOutput
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
