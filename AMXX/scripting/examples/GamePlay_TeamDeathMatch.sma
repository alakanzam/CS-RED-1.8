/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <hamsandwich>
#include <fakemeta_util>
#include <engine>
#include <cstrike>
#include <RandomRespawn>
#include <RespawnBar>
#include <infinitive_round>
#include <cvar_util>
#include <player_api>


#include <GamePlay_Included/GlobalConstants.inc>
#include <GamePlay_Included/Manager.inc>




#define TASK_ProtectionDisabled 2000
#define TASK_END_TDM_GAME 5000
#define TASK_QUIT_TDM_GAME 8000
#define TASK_RESPAWN 11000
#define TASK_SET_GAME_DEFAULT_VALUE 14000
#define TASK_CZ_BOT_FUNCTION 17000

//	BIT TOOLS

#define SetPlayerBit(%1,%2)      (%1 |= (1<<(%2&31)))
#define ClearPlayerBit(%1,%2)    (%1 &= ~(1 <<(%2&31)))
#define CheckPlayerBit(%1,%2)    (%1 & (1<<(%2&31)))			


new Float:fTDM_RoundTime



// Forwards
new ifw_Result
new ifw_GameStart
new ifw_RoundEnd


// Global Variants
new iRoundScore
new iWeaponMode

new iKillCounter_CT
new iKillCounter_T




new iHamCZ = 0

new ifm_Spawn
new iGameMode

enum
{
	TDM_MODE_NONE,
	TDM_MODE_NORMAL
}

/*****************************************************************/

new iCvar_SpawnRender_CT, iCvar_SpawnRender_T
new iCvar_RoundScore, iCvar_WeaponMode, iCvar_RoundTime

/*****************************************************************/
new g_UserBeingProtected

new iRoundEnd

stock szCvarName[][] =
{
	"pb_ffa",
	"mp_friendlyfire",
	"mp_freezetime"
}

stock szCvarValue[][] =
{
	"0",
	"0",
	"0"
}

new Float:fRoundMinute


public plugin_natives()
{
	register_native("TDM_get_game_state", "get_game_state", 1)
	register_native("TDM_get_weapon_mode", "get_weapon_mode", 1)
	register_native("TDM_get_score_terrorist", "get_score_terrorist", 1)
	register_native("TDM_get_score_ct", "get_score_ct", 1)
	register_native("TDM_get_round_score", "get_round_score", 1)
	register_native("TDM_get_round_time", "get_round_time", 1)
}

public get_game_state()
	return iGameMode
	
public get_weapon_mode()
	return iWeaponMode
	
public get_score_terrorist()
	return iKillCounter_T
	
public get_score_ct()
	return iKillCounter_CT
	
public get_round_score()
	return iRoundScore
	
public Float:get_round_time()
	return fRoundMinute

public GamePlay_Initilizing(iRealGamePlay)
{	
	
	if (iRealGamePlay == GAMEMODE_TDM)
		iGameMode = TDM_MODE_NORMAL
	else if (iRealGamePlay == GAMEMODE_BY_PREFIX)
	{
		iGameMode = CheckGameModeMap()
		
		if (iGameMode == TDM_MODE_NORMAL)
			register_gameplay_id(GAMEMODE_TDM)
	}
	
	if (!iGameMode)
	{
		pause("a")
		return
	}
	iCvar_WeaponMode = register_cvar("GamePlay_TDM/WeaponMode", "1")	
	iCvar_RoundScore = register_cvar("GamePlay_TDM/MaxScore", "150")
	iCvar_RoundTime = register_cvar("GamePlay_TDM/RoundTime", "15")
	
	iCvar_SpawnRender_CT = register_cvar("GamePlay_TDM/SpawnRender/CT", "0 200 0")
	iCvar_SpawnRender_T = register_cvar("GamePlay_TDM/SpawnRender/RenderColor", "200 0 0")
	
	
	
	new szConfigDir[64], szCfgFile[256]
	get_configsdir(szConfigDir, sizeof szConfigDir - 1)
	
	new szMapName[32]
	get_mapname(szMapName, sizeof szMapName - 1)
	
	
	#define CONFIGURATION_FILE	"GamePlay_TeamDeathMatch.cfg"
	formatex(szCfgFile, sizeof szCfgFile - 1, "%s/%s", szConfigDir, CONFIGURATION_FILE)
		
	if (file_exists(szCfgFile))
	{
		server_cmd("exec %s", szCfgFile)
		server_exec()
	}
	
	/*				SPECIAL CONFIGURATION				*/
	
	formatex(szCfgFile, sizeof szCfgFile - 1, "%s/GamePlay_TDM/%s.cfg", szConfigDir, szMapName)
	
	if (file_exists(szCfgFile))
	{
		server_cmd("exec %s", szCfgFile)
		server_exec()
	}
	
	/********************************************************************************/
	
	iRoundScore = get_pcvar_num(iCvar_RoundScore)
	iWeaponMode = get_pcvar_num(iCvar_WeaponMode)
		
	ifm_Spawn = register_forward(FM_Spawn, "fw_MissionEntitySpawn")
	register_forward(FM_GetGameDescription, "fw_GetGameDescription")
		
	
}

public plugin_init() 
{
	if (iGameMode)
	{
		unregister_forward(FM_Spawn, ifm_Spawn)
		
		#define PLUGIN 	 "[GAME PLAY] Team Death Match"
		#define VERSION	 "- No Info -"
		#define AUTHOR 	"Redplane"
	
		register_plugin(PLUGIN, VERSION, AUTHOR)
	
		
		fRoundMinute = get_pcvar_float(iCvar_RoundTime)
		fTDM_RoundTime = fRoundMinute  * 60.0
		
		
		
		// Creates some forwards
		ifw_RoundEnd = CreateMultiForward("TDM_game_over", ET_IGNORE, FP_CELL)
		ifw_GameStart = CreateMultiForward("TDM_game_start", ET_IGNORE)
		
		register_message(get_user_msgid("ClCorpse"), "message_ClCorpse")
		
		register_logevent("Event_RoundBegin" , 2 , "1=Round_Start")
		register_forward(FM_SetModel, "fw_SetModel")
		
		
		RegisterHam(Ham_Spawn, "player", "fw_PlayerSpawnPost", 1)
		RegisterHam(Ham_TakeDamage, "player", "fw_PlayerTakeDamage")
		RegisterHam(Ham_TraceAttack, "player", "fw_TraceAttack")
		RegisterHam(Ham_Killed, "player", "fw_PlayerKilled", 1)
		
		
		
		
		for (new iCvarId = 0; iCvarId < sizeof szCvarName; iCvarId++)
		{
			new iCvarPointer = get_cvar_pointer(szCvarName[iCvarId])
			CvarLockValue(iCvarPointer, szCvarValue[iCvarId])
			CvarEnableLock(iCvarPointer)
			
		}
		
		ir_block_round_end(FLAG_ALL)
	}
}

public client_putinserver(id)
{
	if (!iGameMode)
		return
		
	
	set_task(0.1, "RegisterCZFunction_TASK", id + TASK_CZ_BOT_FUNCTION)
}


public fw_MissionEntitySpawn(entity)
{
	// Invalid entity
	if (!pev_valid(entity)) return FMRES_IGNORED;
	
	// Get classname
	new classname[32]
	pev(entity, pev_classname, classname, sizeof classname - 1)
	
	new MISSION_ENTITY[][] = {"func_bomb_target", "info_bomb_target", "info_vip_start", "func_vip_safetyzone", "func_escapezone", "hostage_entity",
		"monster_scientist", "func_hostage_rescue", "info_hostage_rescue"}

		
	// Check whether it needs to be removed
	for (new i = 0; i < sizeof MISSION_ENTITY; i++)
	{
		if (equal(classname, MISSION_ENTITY[i]))
		{
			engfunc(EngFunc_RemoveEntity, entity)
			return FMRES_SUPERCEDE;
		}
	}
	
	return FMRES_IGNORED;
}

public fw_GetGameDescription()
{
	new TDM_DESCRIPTION[] = "Team Death Match"
	forward_return(FMV_STRING, TDM_DESCRIPTION)
	return FMRES_SUPERCEDE;
}

public message_ClCorpse()
{
	if (!iGameMode)
		return PLUGIN_CONTINUE
	return PLUGIN_HANDLED
}

public fw_SetModel(iEnt, const szModel[])
{
	if (!pev_valid(iEnt))
		return

	if (!iGameMode)
		return 
		
		
	if (!equal(szModel[7], "w_", 2))
		return
	
	new szClassName[32]
	pev(iEnt, pev_classname, szClassName, sizeof szClassName - 1)
	
	if (!(equal(szClassName, "weaponbox")))
		return
		
	set_pev(iEnt, pev_nextthink, get_gametime() + WEAPON_STAY_TIME)
	
}

public Event_RoundBegin()
{
	if (iGameMode)
	{
		if (task_exists(TASK_END_TDM_GAME))
			remove_task(TASK_END_TDM_GAME)
		
		ExecuteForward(ifw_GameStart, ifw_Result)
		set_task(fTDM_RoundTime, "TDM_GAME_END_TASK", TASK_END_TDM_GAME)
		
		iRoundEnd = 0
	}
}

public TDM_GAME_END_TASK()
{
	iRoundEnd = 0
	
	set_round_end(1, TEAM_NONE)
	
	/*
	new iPlayers[32], iNumber
	get_players(iPlayers, iNumber, "c")
	for (new i = 0; i < iNumber; i++)
	{
		new id = iPlayers[i]
		set_task(5.0, "QuitGame_TASK", id + TASK_QUIT_TDM_GAME)
	}
	*/
}

public QuitGame_TASK(TASKID)
{
	new id = TASKID - TASK_QUIT_TDM_GAME
	
	if (!is_user_connected(id))
		return
		
		
	console_cmd(id, "quit")
	client_cmd(id, "quit")
}


// Because CZ bot is a strange entity, so we must use this function
public RegisterCZFunction_TASK(TASKID)
{
	new id = TASKID - TASK_CZ_BOT_FUNCTION
	
	if (!iGameMode)
		return
			
	if (!is_user_bot(id))
		return
		
	if (!get_cvar_num("bot_quota"))
		return
		
	
	if (!iHamCZ)
	{
	
		RegisterHamFromEntity(Ham_Spawn, id, "fw_PlayerSpawnPost", 1)
		RegisterHamFromEntity(Ham_TakeDamage, id, "fw_PlayerTakeDamage")
		RegisterHamFromEntity(Ham_TraceAttack, id, "fw_TraceAttack")
		RegisterHamFromEntity(Ham_Killed, id, "fw_PlayerKilled", 1)
		iHamCZ = 1
	}
	if (is_user_alive(id))
		fw_PlayerSpawnPost(id)
	
}

// Respawn a player after he/she was dead
public TASK_RespawnPlayer(TASKID)
{
	new id = TASKID - TASK_RESPAWN
	//if (pev_valid(id) && is_user_connected(id))
	//{
	if (is_user_alive(id))
		return
	if (!is_user_connected(id))
		return
	
	UT_RespawnPlayer(id)
	//show_bartime(id, 0)
	//}
}

// -----------------Hamsandwich function------------------
// Called when a player respawns
public fw_PlayerSpawnPost(id)
{
	
	SetPlayerBit(g_UserBeingProtected, id)
	remove_task(id + TASK_ProtectionDisabled)
	
	if (!is_user_connected(id))
		return
		
				//show_bartime(id, 0)
	new iRed, iGreen, iBlue
	new szRed[10], szGreen[10], szBlue[3]
	new szColor[32]
			
	new CsTeams:iTeam = cs_get_user_team(id)
		
	if (iTeam == CS_TEAM_CT)
		get_pcvar_string(iCvar_SpawnRender_CT, szColor, sizeof szColor - 1)
	else if (iTeam == CS_TEAM_T)
		get_pcvar_string(iCvar_SpawnRender_T, szColor, sizeof szColor - 1)
	
	parse(szColor, szRed, sizeof szRed -1, szGreen, sizeof szGreen - 1, szBlue, sizeof szBlue - 1)
				
	iRed = str_to_num(szRed)
	iGreen = str_to_num(szGreen)
	iBlue = str_to_num(szBlue)
		
	fm_set_rendering(id, kRenderFxGlowShell, iRed, iGreen, iBlue, kRenderNormal, 16)
		
	new iRandom = random(10)
		
	if (iRandom < 7)
	{
		new iMaxPoint = csred_CSDM_SpawnNumber()
			
		if (iMaxPoint)
			csred_DoRandomSpawn(id, SPAWN_TYPE_CSDM)
	}
	
	//fm_set_rendering(id, kRenderFxGlowShell, 255, 255, 255, kRenderNormal, 16)
	
	set_task(PROTECTION_TIME, "DisableTheProtection", id + TASK_ProtectionDisabled)
	
			
}

///////////////////- --- END MENU -----------------------	

// Called when a player takes damage
public fw_PlayerTakeDamage(iVictim, inflictor, iAttacker, Float:damage)
{
	if (!iGameMode)
		return HAM_IGNORED
		
	if (CheckPlayerBit(g_UserBeingProtected, iVictim))
		return HAM_SUPERCEDE
	
	if (!IsValidPlayer(iVictim))
		return HAM_IGNORED
	
	if (!IsValidPlayer(iAttacker))
		return HAM_IGNORED
	
	if (iRoundEnd)
		return HAM_SUPERCEDE
		
	new CsTeams:iAttackerTeam = cs_get_user_team(iAttacker)
	new CsTeams:iVictimTeam = cs_get_user_team(iVictim)
	
	if (iAttackerTeam == iVictimTeam && iVictim != iAttacker)
		return HAM_SUPERCEDE
	
	return HAM_IGNORED
}

public fw_TraceAttack(iVictim, iAttacker, Float:damage, Float:direction[3], trace_result, damagebits)
{
	if (!IsValidPlayer(iVictim))
		return HAM_IGNORED
		
	if (!IsValidPlayer(iAttacker))
		return HAM_IGNORED
	
	if (!iGameMode)
		return HAM_IGNORED
	
	if (iRoundEnd)
		return HAM_SUPERCEDE
		
	if (CheckPlayerBit(g_UserBeingProtected, iVictim))
		return HAM_SUPERCEDE
	
	new CsTeams:iAttackerTeam = cs_get_user_team(iAttacker)
	new CsTeams:iVictimTeam = cs_get_user_team(iVictim)
	if (iAttackerTeam == iVictimTeam && iVictim != iAttacker)
		return HAM_SUPERCEDE
		
	if (iRoundEnd)
		return HAM_SUPERCEDE
		
	return HAM_IGNORED
}

public fw_PlayerKilled(iVictim, iKiller)
{
	if (!iGameMode)
		return
	
	if (iRoundEnd)
		return
		
	if (CheckPlayerBit(g_UserBeingProtected, iVictim))
		ClearPlayerBit(g_UserBeingProtected, iVictim)
		
	new CsTeams:iTeam = cs_get_user_team(iVictim)
	
	if (iTeam == CS_TEAM_CT)
		iKillCounter_T ++
	else if (iTeam == CS_TEAM_T)
		iKillCounter_CT++
		
	if (iKillCounter_CT >= iRoundScore)
	{
		remove_task(TASK_END_TDM_GAME)
		set_round_end(0, TEAM_CT)
		return
			
	}
	else if (iKillCounter_T >= iRoundScore)
	{
		remove_task(TASK_END_TDM_GAME)
		set_round_end(0, TEAM_TERRORIST)
		return
	}
	
	_MakeRespawnTask(iVictim, 0.0, 1)
	
	if (!is_user_bot(iVictim))
		_DrawRespawnNumber(iVictim, 1, 0, 1)
}

//--------------End Hamsandwich function------------------

// Set this task to disable player's protection
public DisableTheProtection(TASKID)
{
	new id = TASKID - TASK_ProtectionDisabled;
	ClearPlayerBit(g_UserBeingProtected, id)
	fm_set_rendering(id)
}

stock set_round_end(iAutoDetect, iTeam)
{
	if (!iGameMode)
		return 0
		
	if (iRoundEnd)
		return 0
		
	if (iAutoDetect)
	{
		if (iKillCounter_CT == iKillCounter_T)
			ExecuteForward(ifw_RoundEnd, ifw_Result, TEAM_NONE)
		else if (iKillCounter_CT < iKillCounter_T)
			ExecuteForward(ifw_RoundEnd, ifw_Result, TEAM_TERRORIST)
		else 
			ExecuteForward(ifw_RoundEnd, ifw_Result, TEAM_CT)
			
		iRoundEnd = 1
		return 1
	}
	
	ExecuteForward(ifw_RoundEnd, ifw_Result, iTeam)
	iRoundEnd = 1
	
	client_cmd(0, "quit")
	console_cmd(0, "quit")
	
	return 1
		
}

stock CheckGameModeMap()
{
	new szMapName[32]
	get_mapname(szMapName, sizeof szMapName - 1)
	
	strtoupper(szMapName)
	
	if (equal(szMapName, "TDM_", 4))
		return TDM_MODE_NORMAL
	
	return 0
}




stock IsValidPlayer(id)
{

	if (!is_user_connected(id))
		return 0
		
	return 1
}
