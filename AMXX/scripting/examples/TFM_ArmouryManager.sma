/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <cstrike>
#include <csx>
#include <hamsandwich>

#include <TFM_MdlReplace>
#include <ArmouryManager>
#include <cswpn_ultilities>


#include <WpnMod_Included/WM_COMMAND.inc>



#define MAX_SPAWN_POINT 32



#define ARMOURY_DIRECTORY	"WPN_MOD/DEFAULT"
#define ARMOURY_POSTFIX		"cfg"

new g_TotalSpawns, Float:g_SpawnVecs[MAX_SPAWN_POINT][3]
new iSpawnWeaponId[MAX_SPAWN_POINT]

new iArmouryMenuId


new ifw_ArmouryCreating
new ifw_ArmouryPickedUp
new ifw_UserCanTouchArmoury
new ifw_ArmourySetModel

new ifw_Result





new HamHook:ifw_ArmourySpawn


public plugin_natives()
	register_native("DFWM_set_armoury_spawn", "nt_DFWM_set_armoury_spawn", 1)

public nt_DFWM_set_armoury_spawn(iPoint, iArmouryId, Float:fOrigin[3])
	CreateArmoury(iPoint, iArmouryId, fOrigin)


public plugin_precache()
{
		
	ifw_ArmouryCreating = CreateMultiForward("DFWM_ArmouryCreating", ET_IGNORE, FP_CELL)
	ifw_ArmouryPickedUp = CreateMultiForward("DFWM_ArmouryPickedUp", ET_IGNORE, FP_CELL, FP_CELL)
	ifw_UserCanTouchArmoury = CreateMultiForward("DFWM_CanUserUseArmoury", ET_CONTINUE, FP_CELL, FP_CELL)
	ifw_ArmourySetModel = CreateMultiForward("DFWM_ArmourySetModel", ET_CONTINUE, FP_CELL, FP_CELL, FP_STRING)
	
	
	
	ifw_ArmourySpawn = RegisterHam(Ham_Spawn, "armoury_entity", "fw_ArmouryRespawned")
	
}
	
public plugin_init() 
{
	
	
	#define PLUGIN "[ARMOURY] DEFAULT ARMOURY"
	#define VERSION "-[No Info]-"
	#define AUTHOR "Nguyen Duy Linh"
		
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_dictionary("TFM_ArmouryManager.txt")
	
	new szMenuTitle[128]
	formatex(szMenuTitle, sizeof szMenuTitle - 1, "%L", LANG_SERVER, "TITLE_ARMOURY_MENU")
	
	iArmouryMenuId = menu_create(szMenuTitle, "fw_ArmouryItemSelected")
	
	//fw_ArmourySpawn()
	register_concmd(DEFAULT_ARMOURY_CMD, "concmd_OpenArmouryMenu")
	
	
	register_logevent("LogEvent_RoundBegin" , 2 , "1=Round_Start")
	register_event("HLTV", "Event_RoundBegin", "a", "1=0", "2=0")
	register_touch("armoury_entity", "player", "fw_ArmouryTouch")
	register_forward(FM_SetModel, "fw_SetModel")
	
	DisableHamForward(ifw_ArmourySpawn)
	new szCfgDir[128], szMapName[32]
	
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	get_mapname(szMapName, sizeof szMapName - 1)
	
	
	for (new iWeaponId = CSW_P228; iWeaponId < CSW_P90 + 1; iWeaponId++)
	{
		if (iWeaponId == 2)
			continue
			
		

		new szSpawnFile[128]
		new szInfo[10]
		formatex(szInfo, sizeof szInfo - 1, "%d", iWeaponId)
			
		
		new szWeaponName[32]
		UT_Get_CS_Name(iWeaponId, szWeaponName, sizeof szWeaponName - 1)
		menu_additem(iArmouryMenuId, szWeaponName, szInfo, ADMIN_MENU)
			
			
			
		get_weaponname(iWeaponId, szWeaponName, sizeof szWeaponName - 1)
		formatex(szSpawnFile, sizeof szSpawnFile - 1, "%s/%s/%s/%s.%s", szCfgDir, ARMOURY_DIRECTORY, szMapName, szWeaponName, ARMOURY_POSTFIX)
		
		if (!file_exists(szSpawnFile))
			continue
			
		new Data[124], len;
		new line = 0;
		new pos[11][8];
			
			
		while(g_TotalSpawns < MAX_SPAWN_POINT && (line = read_file(szSpawnFile , line , Data , 123 , len) ) != 0 ) 
		{
			if (strlen(Data)<2) continue;
			parse(Data, pos[1], 7, pos[2], 7, pos[3], 7)
			// Origin
				
			g_SpawnVecs[g_TotalSpawns][0] = str_to_float(pos[1]);
			g_SpawnVecs[g_TotalSpawns][1] = str_to_float(pos[2]);
			g_SpawnVecs[g_TotalSpawns][2] = str_to_float(pos[3]);
				
			iSpawnWeaponId[g_TotalSpawns] = iWeaponId
				
			g_TotalSpawns++;
		}
	}
}

public fw_ArmouryRespawned(iEnt)
{
	new iArmouryType = pev(iEnt, pev_ArmouryType)
		
		
	if (iArmouryType == ARMOURY_DEFAULT || iArmouryType == ARMOURY_PRIMARY || iArmouryType == ARMOURY_SECONDARY || iArmouryType == ARMOURY_GRENADE)
		return HAM_IGNORED
		
	if (g_TotalSpawns > MAX_SPAWN_POINT - 1)
	{
		engfunc(EngFunc_RemoveEntity, iEnt)
		return HAM_SUPERCEDE
	}
		
	new Float:fOrigin[3]
	
	pev(iEnt, pev_origin, fOrigin)
	
	g_SpawnVecs[g_TotalSpawns][0] = fOrigin[0]
	g_SpawnVecs[g_TotalSpawns][1] = fOrigin[1]
	g_SpawnVecs[g_TotalSpawns][2] = fOrigin[2]
	
	//iSpawnWeaponId[g_TotalSpawns] = CSWPN_ID[random(sizeof CSWPN_ID)]
	iSpawnWeaponId[g_TotalSpawns] = cs_get_armoury_type(iEnt)
	g_TotalSpawns++
	engfunc(EngFunc_RemoveEntity, iEnt)
	return HAM_SUPERCEDE
}

public fw_ArmouryItemSelected(id, iMenuId, iItemId)
{
	if (!is_user_alive(id))
		return
		
	if (iItemId == MENU_EXIT)
		return
		
	new szItemName[128], szInfo[10], iCALL_BACK, iACCESS_TYPE
	menu_item_getinfo(iMenuId, iItemId, iACCESS_TYPE, szInfo, sizeof szInfo - 1, szItemName, sizeof szItemName - 1, iCALL_BACK)
	
	new iWeaponId = str_to_num(szInfo)
	
	CreateArmourySpawn(id, iWeaponId)
	menu_display(id, iArmouryMenuId, 0)
}


	
public concmd_OpenArmouryMenu(id)
{
	if (!is_user_alive(id))
		return
	if (!is_user_admin(id))
		return
	menu_display(id, iArmouryMenuId, 0)
}


public LogEvent_RoundBegin()
{
	for (new i = 0; i < g_TotalSpawns; i++)
		CreateArmoury(i, -1, Float:{0.0, 0.0, 0.0})
}

public Event_RoundBegin()
{
	
	
	
}


public fw_ArmouryTouch(iEnt, id)
{
		
	if (!is_user_alive(id))
		return PLUGIN_CONTINUE
		
	if (!pev_valid(iEnt) || !iEnt)
		return PLUGIN_CONTINUE
	
	if (pev(iEnt, pev_ArmouryType)!= ARMOURY_DEFAULT)
		return PLUGIN_CONTINUE
	
	new iWeaponId = pev(iEnt, pev_ArmouryId)
	
	if (iWeaponId < CSW_P228 || iWeaponId > CSW_P90 || iWeaponId == 2)
	{
		engfunc(EngFunc_RemoveEntity, iEnt)
		return PLUGIN_HANDLED
	}
	
	new szWeaponName[32]
	get_weaponname(iWeaponId, szWeaponName, sizeof szWeaponName - 1)
	
	if (!can_player_touch_armoury(id, iWeaponId))
		return PLUGIN_HANDLED
		
	if (is_primary_wpn(iWeaponId))
	{
		if (cs_get_user_hasprim(id))
			return PLUGIN_HANDLED
			
		new iWeaponEnt = fm_give_item(id, szWeaponName)
		
		if (!pev_valid(iWeaponEnt))
			return PLUGIN_HANDLED
			
		engclient_cmd(id, szWeaponName)
		cs_set_weapon_ammo(iWeaponEnt, UT_Get_CS_DefaultClip(iWeaponId))
		UT_SetUserBPA(id, iWeaponId, UT_Get_CS_DefaultBpa(iWeaponId))
	}
	else if (is_secondary_wpn(iWeaponId))
	{
		if (user_has_weapon(id, CSW_USP))
			return PLUGIN_HANDLED
			
		if (user_has_weapon(id, CSW_GLOCK18))
			return PLUGIN_HANDLED
			
		if (user_has_weapon(id, CSW_DEAGLE))
			return PLUGIN_HANDLED
			
		if (user_has_weapon(id, CSW_P228))
			return PLUGIN_HANDLED
			
		if (user_has_weapon(id, CSW_ELITE))
			return PLUGIN_HANDLED
			
		if (user_has_weapon(id, CSW_FIVESEVEN))
			return PLUGIN_HANDLED
		
		new iWeaponEnt = fm_give_item(id, szWeaponName)
		
		if (!pev_valid(iWeaponEnt))
			return PLUGIN_HANDLED
			
		engclient_cmd(id, szWeaponName)
		cs_set_weapon_ammo(iWeaponEnt, UT_Get_CS_DefaultClip(iWeaponId))
		UT_SetUserBPA(id, iWeaponId, UT_Get_CS_DefaultBpa(iWeaponId))
		
	}
	else if (is_grenade(iWeaponId))
	{
		if (user_has_weapon(id, iWeaponId))
			return PLUGIN_HANDLED
			
		new iWeaponEnt = fm_give_item(id, szWeaponName)
		
		if (!pev_valid(iWeaponEnt))
			return PLUGIN_HANDLED
			
		engclient_cmd(id, szWeaponName)
	}
	
	ExecuteForward(ifw_ArmouryPickedUp, ifw_Result, id, iEnt)
	engfunc(EngFunc_RemoveEntity, iEnt)
	
	
	return PLUGIN_HANDLED
}


stock fm_give_item(index, const item[]) {
	if (!equal(item, "weapon_", 7) && !equal(item, "ammo_", 5) && !equal(item, "item_", 5) && !equal(item, "tf_weapon_", 10))
		return 0;

	new ent = create_entity(item);
	if (!pev_valid(ent))
		return 0;

	new Float:origin[3];
	pev(index, pev_origin, origin);
	set_pev(ent, pev_origin, origin);
	set_pev(ent, pev_spawnflags, pev(ent, pev_spawnflags) | SF_NORESPAWN);
	dllfunc(DLLFunc_Spawn, ent);

	new save = pev(ent, pev_solid);
	dllfunc(DLLFunc_Touch, ent, index);
	if (pev(ent, pev_solid) != save)
		return ent;

	engfunc(EngFunc_RemoveEntity, ent);

	return -1;
}
	
stock CreateArmourySpawn(id, iWeaponId)
{
	if (iWeaponId < CSW_P228 || iWeaponId > CSW_P90 || iWeaponId == 2)
	{
		client_print(id, print_chat, "%L", LANG_SERVER, "MSG_NOT_VALID_ARMOURY")
		return
	}
	
	if (g_TotalSpawns > MAX_SPAWN_POINT - 1)
	{
		client_print(id, print_center, "%L", LANG_PLAYER, "MSG_MAX_ARMOURY_REACHED")
		return
	}
		
	new Float:origin[3]
	pev(id, pev_origin, origin)
	
	new szCfgDir[128], szMapName[32], szSpawnFile[256]
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	get_mapname(szMapName, sizeof szMapName - 1)
	
	formatex(szSpawnFile, sizeof szSpawnFile - 1, "%s/%s", szCfgDir, ARMOURY_DIRECTORY)
	
	if (!dir_exists(szSpawnFile))
		mkdir(szSpawnFile)
		
	if (!dir_exists(szSpawnFile))
		return
		
	formatex(szSpawnFile, sizeof szSpawnFile - 1, "%s/%s/%s", szCfgDir, ARMOURY_DIRECTORY, szMapName)
	
	if (!dir_exists(szSpawnFile))
		mkdir(szSpawnFile)
		
	if (!dir_exists(szSpawnFile))
		return
		
	
	new szWeaponName[32]
	get_weaponname(iWeaponId, szWeaponName, sizeof szWeaponName - 1)
	
	formatex(szSpawnFile, sizeof szSpawnFile - 1, "%s/%s/%s/%s.%s", szCfgDir, ARMOURY_DIRECTORY, szMapName, szWeaponName, ARMOURY_POSTFIX)
	
	new iOrigin[3]
	get_user_origin(id, iOrigin, 0)
	
	new szLine[64]
	formatex(szLine, sizeof szLine - 1, "%d %d %d", iOrigin[0], iOrigin[1], iOrigin[2])
	
	new iWriteResult = write_file(szSpawnFile, szLine, -1)
	if (!iWriteResult)
	{
		return
	}
	else 
	{
		g_SpawnVecs[g_TotalSpawns][0] = origin[0]
		g_SpawnVecs[g_TotalSpawns][1] = origin[1]
		g_SpawnVecs[g_TotalSpawns][2] = origin[2]
		iSpawnWeaponId[g_TotalSpawns] = iWeaponId
		g_TotalSpawns++
	}
}

stock CreateArmoury(iPoint, iArmouryId, Float:fOrigin[3])
{
	
	ExecuteForward(ifw_ArmouryCreating, ifw_Result, iArmouryId)
	
	new iEnt = create_entity("armoury_entity")
	
	if (!pev_valid(iEnt))
		return
		
	dllfunc ( DLLFunc_Spawn, iEnt );
	
	set_pev(iEnt, pev_solid, SOLID_TRIGGER)
	set_pev(iEnt, pev_ArmouryType, ARMOURY_DEFAULT)
	set_pev(iEnt, pev_ArmouryStatus, ARMOURY_ENABLED)
				
	if (iPoint >= 0)
	{
		iArmouryId = iSpawnWeaponId[iPoint]
		set_pev(iEnt, pev_ArmouryId, iArmouryId)
		set_pev(iEnt, pev_origin, g_SpawnVecs[iPoint])
	}
	else
	{
		set_pev(iEnt, pev_ArmouryId, iArmouryId)
		set_pev(iEnt, pev_origin, fOrigin)
	}
	set_pev(iEnt, pev_mins, {-3.0, -3.0, -3.0})
	set_pev(iEnt, pev_maxs, {3.0, 3.0, 3.0})
				
	new szWorldModel[64]
	UT_WeaponIdToWorldModel(iArmouryId, szWorldModel, sizeof szWorldModel)
	
	ExecuteForward(ifw_ArmourySetModel, ifw_Result, iEnt, iArmouryId, szWorldModel)
	if (ifw_Result == PLUGIN_CONTINUE)
		UT_SetEntityModel(iEnt, szWorldModel, -1)
		
	engfunc(EngFunc_DropToFloor, iEnt)
	set_pev(iEnt, pev_ArmouryPoint, iPoint)
	
}

public fw_SetModel(iEnt, szModel[])
{
	if (!pev_valid(iEnt))
		return FMRES_IGNORED
		
	new szClassName[32]
	pev(iEnt, pev_classname, szClassName, sizeof szClassName - 1)
	
	if (!(equal(szClassName, "armoury_entity")))
		return FMRES_IGNORED
		
	return FMRES_SUPERCEDE
}
stock PlayWavSound(id, szSound[])
{
	if (!id)
	{
		new iPlayers[32], iNumber
		get_players(iPlayers, iNumber, "c")
		
		for (new i = 0; i < iNumber; i++)
			client_cmd(iPlayers[i], "spk %s", szSound)
			
		return
	}
	client_cmd(id, "spk %s", szSound)
}

stock can_player_touch_armoury(id, iWeaponId)
{
	ExecuteForward(ifw_UserCanTouchArmoury, ifw_Result, id, iWeaponId)
	
	if (ifw_Result != PLUGIN_CONTINUE)
		return 0
		
	return 1
}
