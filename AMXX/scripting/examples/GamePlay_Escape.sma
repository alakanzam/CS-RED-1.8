/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta_util>
#include <hamsandwich>
#include <cstrike>
#include <engine>
#include <round_terminator>
#include <engine>
#include <RespawnBar>
#include <player_api>

#include <infinitive_round>

#include <GamePlay_Included/GlobalConstants.inc>
#include <GamePlay_Included/Manager.inc>

#define PLUGIN "[GAME PLAY] ESCAPE"
#define VERSION "-[No Info]-"
#define AUTHOR "Nguyen Duy Linh"

/*			TASK				*/

#define TASK_END_ROUND	1000
#define TASK_CZ_FUNCTION 2000
#define TASK_PROTECT	5000
#define TASK_SHUTDOWN	10000

/********************************************************/


/*			CONSTANT			*/

#define ESCAPE_SOUND "TFM/GamePlay_Escape/EscapeSuccessful.wav"

/********************************************************/		
		
		
/************************** FORWARD *******************************/



new ifw_EscapePre // Called when a player reaches Escape Point
new ifw_EscapePost // Called when a player reaches Escape Post (After)
new ifw_EscapeRoundEnd // Called when round end

new ifw_ForwardResult // Result of a forward

 
/******************************************************************/
new ifm_EntitySpawn
/******************************************************************/

new bool:bRoundEnd

/******************************************************************/

new iCheckMap = 0
new iEscapeTeamScore = 0
new iHamCz = 0

new iEscapeTime = 20 // How many time does escaping team have to do to win ?

/******************************************************************/


/******************************************************************/

new Float:fActiveTime = 0.0 // How long can player escape ?
new Float:fRoundTime_Minute = 15.0 // How long can a round last?

/******************************************************************/


new iMaxPlayers

//	BIT TOOLS

#define SetPlayerBit(%1,%2)      (%1 |= (1<<(%2&31)))
#define ClearPlayerBit(%1,%2)    (%1 &= ~(1 <<(%2&31)))
#define CheckPlayerBit(%1,%2)    (%1 & (1<<(%2&31)))

new bInProtect


		
public plugin_natives()
{
	register_native("EM_GetGameState", "native_get_game_state", 1)
	register_native("EM_GetEscapeTeamScore", "native_get_escape_team_score", 1)
	register_native("EM_GetMaxEscape", "native_max_escape", 1)
	register_native("EM_GetRoundTime", "native_get_round_time", 1)
	register_native("EM_UserReachEsZone", "native_UserReachEsZone", 1)
}

public native_get_game_state()
	return iCheckMap

public native_get_escape_team_score()
	return iEscapeTeamScore

public native_max_escape()
	return iEscapeTime
	
public Float:native_get_round_time()
	return fRoundTime_Minute

public native_UserReachEsZone(id)
{
	if (!is_user_connected(id))
		return
		
	if (!is_user_alive(id))
		return 
		
	new CsTeams:iTeam = cs_get_user_team(id)
	
	if (iTeam != CS_TEAM_T)
		return 
		
	new Float:fCurrentTime = get_gametime()
	
	if (fCurrentTime  < fActiveTime)
		return 
		
	if (bRoundEnd)
		return
		
	ExecuteForward(ifw_EscapePre, ifw_ForwardResult, id)
	
	client_cmd(id, "spk %s", ESCAPE_SOUND)
	
	new szName[32]
	get_user_name(id, szName, sizeof szName - 1)
	
	for (new iPlayer = 1; iPlayer <= iMaxPlayers; iPlayer++)
	{
		if (!is_user_connected(iPlayer))
			continue
			
		if (is_user_bot(iPlayer))
			continue
			
		if (iPlayer == id)
			continue
		
		client_print(iPlayer, print_center, "%L", iPlayer, "USER_ESCAPE_SUCCESSFULLY", szName)
	}
	
	#define ESCAPE_DELAY_TIME	5.0
	client_print(0, print_chat, "%L", 0, "TER_CAN_ESCAPE_AFTER", floatround(ESCAPE_DELAY_TIME))
	
	//	SET NEW CHECK POINT FOR TIME OF ESCAPE
	fActiveTime = fCurrentTime + ESCAPE_DELAY_TIME
	
	make_deathmsg(id, id, 0, "run")
	
	
	ExecuteHamB(Ham_CS_RoundRespawn, id)
	ExecuteForward(ifw_EscapePost, ifw_ForwardResult, id)
	
	iEscapeTeamScore++
	
	if (iEscapeTeamScore >= iEscapeTime)
	{
		new Float:ESCAPE_SHUTDOWN_DELAY = 5.0
		
		ExecuteForward(ifw_EscapeRoundEnd, ifw_ForwardResult, TEAM_TERRORIST)		
		set_task(ESCAPE_SHUTDOWN_DELAY, "Event_ForceShutDown", TASK_SHUTDOWN)
		
		bRoundEnd = true
	}
	
	return 
}

public GamePlay_Initilizing(iRealGamePlay)
{
	
	
	iCheckMap = is_valid_map()
	
	if (iRealGamePlay != GAMEMODE_BY_PREFIX && iRealGamePlay != GAMEMODE_ESCAPE)
		iCheckMap = 0
	
	if (iCheckMap)
	{
		register_forward(FM_GetGameDescription, "fw_GetGameDescription")
		ifm_EntitySpawn = register_forward(FM_Spawn, "fw_MissionEntitySpawns")	
		register_gameplay_id(GAMEMODE_ESCAPE)
	
	}	
	else
	{
		pause("a")
		return
	}
}

public plugin_init()
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	if (!iCheckMap)
		return
		
	
	ifw_EscapePre = CreateMultiForward("ES_UserEscapePre", ET_IGNORE, FP_CELL)
	ifw_EscapePost = CreateMultiForward("ES_UserEscapePost", ET_IGNORE, FP_CELL)
	ifw_EscapeRoundEnd = CreateMultiForward("ES_RoundEnd", ET_IGNORE, FP_CELL)
	
	register_message(get_user_msgid("TextMsg"), "message_TextMsg")
	register_message(get_user_msgid("ClCorpse"), "message_ClCorpse")
	register_message(get_user_msgid("SendAudio"), "message_SendAudio")
	
	
	register_logevent("Event_RoundBegin" , 2 , "1=Round_Start")
	register_event("TextMsg","Event_RoundRestart","a","2=#Game_Commencing","2=#Game_will_restart_in")
	
	register_forward(FM_SetModel, "fw_SetModel")
	
	register_touch("func_escapezone", "player", "fw_PlayerReachedEscapeZone")
	
	RegisterHam(Ham_Spawn, "player", "fw_SpawnPost", 1)
	RegisterHam(Ham_TakeDamage, "player", "fw_TakeDamage")
	RegisterHam(Ham_TraceAttack, "player", "fw_TraceAttack")
	RegisterHam(Ham_Killed, "player", "fw_KilledPost", 1)
	
	unregister_forward(FM_Spawn, ifm_EntitySpawn)
	
	iMaxPlayers = get_maxplayers()

	
	new iCvarId_RoundTime
	new iCvarId_EscapeTime
	
	iCvarId_RoundTime = register_cvar("GamePlay_ESC/RoundTime", "15.0")
	iCvarId_EscapeTime = register_cvar("GamePlay_ESC/EscapeTime", "20")
	
	/****************************************************************************/
	new CFG_FILE_NAME[] = "GamePlay_Escape.cfg"
	
	new szCfgFile[128], szCfgDir[64]
	
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	formatex(szCfgFile, sizeof szCfgFile - 1, "%s/%s", szCfgDir, CFG_FILE_NAME)
	
	server_exec()
	server_cmd("exec %s", szCfgFile)
	server_exec()
	
	fRoundTime_Minute = get_pcvar_float(iCvarId_RoundTime)
	iEscapeTime = get_pcvar_num(iCvarId_EscapeTime)
	
	/****************************************************************************/
	
}

public plugin_cfg()
{
	if (!iCheckMap)
		return
		
	ir_block_round_end(FLAG_ALL)
}

public fw_GetGameDescription()
{
	new ESC_DESCRIPTION[] =	"Escape"
	forward_return(FMV_STRING, ESC_DESCRIPTION)
	return FMRES_SUPERCEDE;
}
	
public client_putinserver(id)
	if (is_user_bot(id))
		set_task(0.1, "fw_RegisterCzFunction", id + TASK_CZ_FUNCTION)

public fw_MissionEntitySpawns(iEnt)
{
	if (!iCheckMap)
		return FMRES_IGNORED
		
	if (!pev_valid(iEnt)) 
		return FMRES_IGNORED;
	
	// Get classname
	new classname[32]
	pev(iEnt, pev_classname, classname, sizeof classname - 1)
	
	new MISSION_ENTITY[][] = {"func_bomb_target", "info_bomb_target", "info_vip_start", "func_vip_safetyzone", "hostage_entity",
		"monster_scientist", "func_hostage_rescue", "info_hostage_rescue"}
		
	// Check whether it needs to be removed
	for (new i = 0; i < sizeof MISSION_ENTITY; i++)
	{
		if (equal(classname, MISSION_ENTITY[i]))
		{
			engfunc(EngFunc_RemoveEntity, iEnt)
			return FMRES_SUPERCEDE;
		}
	}
	
	return FMRES_IGNORED;
}

/*					MESSAGE FUNCTION			*/

public message_TextMsg()
{
	if (!iCheckMap)
		return PLUGIN_CONTINUE
	static textmsg[22]
	get_msg_arg_string(2, textmsg, sizeof textmsg - 1);
	if (equal(textmsg, "#Hostages_Not_Rescued") || equal(textmsg, "#CTs_PreventEscape") || equal(textmsg, "#Escaping_Terrorists_Neutralized") || equal(textmsg, "#Terrorists_Win") || equal(textmsg, "#CTs_Win"))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public message_SendAudio()
{
	static audio[17]
	get_msg_arg_string(2, audio, sizeof audio - 1)
	
	if (!iCheckMap)
		return PLUGIN_CONTINUE
		
	if(equal(audio, "%!MRAD_TERWIN", 13 ) || equal(audio, "%!MRAD_CTWIN" ,12) || equal(audio, "%!MRAD_ROUNDDRAW", 16))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE;
}

public message_ClCorpse(msg_id, msg_dest, msg_ent)
{
	if (!iCheckMap)
		return PLUGIN_CONTINUE
	return PLUGIN_HANDLED
}

public Event_RoundBegin()
{	
	if (!iCheckMap)
		return
		
	
	iEscapeTeamScore = 0
	bRoundEnd = false
	
	remove_task(TASK_END_ROUND)
	
	new Float:fRoundTime_Second = fRoundTime_Minute * 60.0
	set_task(fRoundTime_Second, "Event_ForceEndRound", TASK_END_ROUND)
	
	iEscapeTeamScore = 0
	
}

public Event_RoundRestart()
{
	bRoundEnd = true
	iEscapeTeamScore = 0
}

/*			FAKEMETA FUNCTION		*/

public fw_SetModel(iEnt, const szModel[])
{
	if (!pev_valid(iEnt))
		return 
		
	if (!iCheckMap)
		return
		
	new szClassName[32]
	pev(iEnt, pev_classname, szClassName, sizeof szClassName)
	
	if (!(equal(szClassName, "weaponbox")))
		return
		
	set_pev(iEnt, pev_nextthink, get_gametime() + WEAPON_STAY_TIME)
	
}


/********************************************************/

/*			ENGINE FUNCTION		        */

public fw_PlayerReachedEscapeZone(iEnt, id)
{
	if ( !pev_valid(iEnt))
		return
		
	if (!iCheckMap)
		return
		
	native_UserReachEsZone(id)
}
/*			HAMSANDWICH FUNCTION		*/

public fw_SpawnPost(id)
{
	if (!iCheckMap)
		return
		
	new Float:ESCAPE_PROTECT_TIME = 3.0;
	
	SetPlayerBit(bInProtect, id)
	set_task(ESCAPE_PROTECT_TIME, "fw_ProtectionDisabled", id + TASK_PROTECT)
	
	if (!is_user_connected(id))
		return
		
	new CsTeams:Team = cs_get_user_team(id)
		
	if (Team == CS_TEAM_CT)
		fm_set_rendering(id, kRenderFxGlowShell, 255 ,0, 0, kRenderNormal, 16)
	else if (Team == CS_TEAM_T)
		fm_set_rendering(id, kRenderFxGlowShell, 0, 255, 0, kRenderNormal, 16)
}

public fw_TakeDamage(iVictim, inflictor, iAttacker, Float:damage, damagebit)
{
	if (!iCheckMap)
		return HAM_IGNORED
		
	if (!is_user_connected(iVictim) || !is_user_connected(iAttacker))
		return HAM_IGNORED
		
	if (CheckPlayerBit(bInProtect, iVictim))
		return HAM_SUPERCEDE
		
	if(bRoundEnd)
		return HAM_SUPERCEDE
		
	new CsTeams:iTeamV = cs_get_user_team(iVictim)
	new CsTeams:iTeamA = cs_get_user_team(iAttacker)
	
	if (iVictim == iAttacker)
		return HAM_IGNORED
	
	if (iTeamV == iTeamA)
		return HAM_SUPERCEDE
		
	return HAM_IGNORED
}

public fw_TraceAttack(iVictim, iAttacker, Float:damage, Float:direction[3], tracehandle, damage_type)
{
	if (!iCheckMap)
		return HAM_IGNORED
		
	if (!is_user_connected(iAttacker) || !is_user_connected(iVictim))
		return HAM_IGNORED
		
	if (CheckPlayerBit(bInProtect, iVictim))
		return HAM_SUPERCEDE
		
	if (bRoundEnd)
		return HAM_SUPERCEDE
			
	new CsTeams:iTeamV = cs_get_user_team(iVictim)
	new CsTeams:iTeamA = cs_get_user_team(iAttacker)
	
	if (iVictim == iAttacker)
		return HAM_IGNORED
	
	if (iTeamV == iTeamA)
		return HAM_SUPERCEDE
		
	return HAM_IGNORED;
}

public fw_KilledPost(iVictim, iKiller)
{
	if (!iCheckMap)
		return
		
	if (!(1<= iVictim <= iMaxPlayers))
		return
	
	_MakeRespawnTask(iVictim, 0.0, 1)
	_DrawRespawnNumber(iVictim, 1, 0, 1)
	
}


/*			MAIN TASK			*/

public fw_ProtectionDisabled(TASKID)
{
	if (!iCheckMap)
		return
		
	new id = TASKID - TASK_PROTECT
	
	if (!is_user_connected(id))
		return
		
	ClearPlayerBit(bInProtect, id)
	
	fm_set_rendering(id)
}

public fw_RegisterCzFunction(TASKID)
{
	new id = TASKID - TASK_CZ_FUNCTION
	
	if (!is_user_bot(id))
		return
		
	if (!get_cvar_num("bot_quota"))
		return
		
	if (iHamCz)
		return
		
	RegisterHamFromEntity(Ham_Spawn, id, "fw_SpawnPost", 1)
	RegisterHamFromEntity(Ham_TakeDamage, id, "fw_TakeDamage")
	RegisterHamFromEntity(Ham_TraceAttack, id, "fw_TraceAttack")
	RegisterHamFromEntity(Ham_Killed, id, "fw_KilledPost", 1)
	iHamCz = 1
}


/************************************************/

/************************************************/


public Event_ForceEndRound(TASKID)
{
	if (!iCheckMap)
		return
		
	if (bRoundEnd)
		return
		
	bRoundEnd = true
		
	new Float:ESCAPE_SHUTDOWN_DELAY = 5.0
	
	ExecuteForward(ifw_EscapeRoundEnd, ifw_ForwardResult, TEAM_CT)
	set_task(ESCAPE_SHUTDOWN_DELAY, "Event_ForceShutDown", TASK_SHUTDOWN)
}

public Event_ForceShutDown()
	console_cmd(0, "quit")
	

/************************************************/

/*			STOCKS			*/



stock is_valid_map()
{
	new szMapName[32]
	
	get_mapname(szMapName, sizeof szMapName - 1)
	
	strtoupper(szMapName)
	
	if (equal(szMapName, "ES_", 3))
		return 1
		
	return 0
}

stock load_map_escape_point(szMapName[])
{
	new szCfgDir[128], szCfgFile[256]
	
	get_configsdir(szCfgDir, sizeof szCfgDir - 1)
	formatex(szCfgFile, sizeof szCfgFile - 1, "%s/%s/%s.cfg", szCfgDir, ZONE_DIRECTORY, szMapName)
	
	if (!file_exists(szCfgFile))
		return 0
		
	for (new i = 0; i < file_size(szCfgFile, 1); i++)
	{
		new szText[128], iTextLen
		
		read_file(szCfgFile, i, szText, sizeof szText - 1, iTextLen)
		new szFirstInfo[10], szSecondInfo[10], szThirdInfo[10]
		parse(szText, szFirstInfo, sizeof szFirstInfo - 1, szSecondInfo , sizeof szSecondInfo - 1, szThirdInfo, sizeof szThirdInfo - 1)
		
		new Float:fOrigin[3]
		fOrigin[0] = str_to_float(szFirstInfo)
		fOrigin[1] = str_to_float(szSecondnfo)
		fOrigin[2] = str_to_float(szThirdInfo)
		
		create_zone_entity(fOrigin)
	}
	return 1
}

stock get_same_modelindex(modelindex)
{
	if (modelindex == 1)
		return 2
	if (modelindex == 2)
		return 1
	if (modelindex == 3)
		return 5
	if (modelindex == 4)
		return 7
	if (modelindex == 5)
		return 3
	if (modelindex == 6)
		return 8
	if (modelindex == 7)
		return 4
	if (modelindex == 8)
		return 6
	if (modelindex == 11)
		return 10
	if (modelindex == 10)
		return 11
	return 0
}

