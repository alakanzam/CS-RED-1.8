/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <fakemeta>
#include <hamsandwich>
#include <xs>
#include <cstrike>

#include <cstrike_pdatas>

#include <g4u_wpn>
#include <WpnMod_Included/WM_DefaultArmoury.inc>
#include <Item_Included/ArmorSystem.inc>
#include <cswpn_info>
#include <CHARACTER_MOD>

#include <GamePlay_Included/TFM_ZombieMod.inc>

#define PLUGIN "[TFM] Weapons In Zombie Mod"
#define VERSION "-[No Info]-"
#define AUTHOR "Redplane"


#define SECONDARY_WEAPONS_BITSUM	(1<<CSW_GLOCK18|1<<CSW_USP|1<<CSW_DEAGLE|1<<CSW_P228|1<<CSW_ELITE|1<<CSW_FIVESEVEN)
#define PRIMARY_WEAPONS_BITSUM	(1<<CSW_M3|1<<CSW_XM1014|1<<CSW_MP5NAVY|1<<CSW_TMP|1<<CSW_P90|1<<CSW_MAC10|1<<CSW_UMP45|1<<CSW_GALIL|1<<CSW_FAMAS|1<<CSW_AK47|1<<CSW_M4A1|1<<CSW_SG552|1<<CSW_AUG|1<<CSW_SCOUT|1<<CSW_AWP|1<<CSW_G3SG1|1<<CSW_SG550|1<<CSW_M249)

#define is_secondary_wpn(%1)      (SECONDARY_WEAPONS_BITSUM & (1<<%1))
#define is_primary_wpn(%1)      (PRIMARY_WEAPONS_BITSUM & (1<<%1))

/*		RADIO DIRECTORY OF ZOMBIE	*/
#define ZOMBIE_MALE_RADIO "radio/MALE_ZOMBIE" // Directory stores Radio sound of Male Zombie
#define ZOMBIE_FEMALE_RADIO "radio/FEMALE_ZOMBIE" // Directory stores Radio sound of Female Zombie

new iHAM_CZ

new iCvarKnockBack
public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	iHAM_CZ = 0
	
	iCvarKnockBack = register_cvar("KbPower", "6.0")
	
	RegisterHam(Ham_TraceAttack, "player", "fw_PlayerTraceAttack")
	// Add your code here...
}

public plugin_cfg()
{
	if (!zp_is_mode_on())
	{
		set_fail_state("ZOMBIE MOD IS OFF")
		return
	}
}

public client_putinserver(id)
{
	remove_task(id + TASK_CZ_FUNCTION)
		
	if (iHAM_CZ)
		return
		
	set_task(0.1, "RegisterCzFunction_TASK", id + TASK_CZ_FUNCTION)
}

public RegisterCzFunction_TASK(TASKID)
{
	new id = TASKID - TASK_CZ_FUNCTION
	
	if (!is_user_connected(id))
		return
		
	if (!is_user_bot(id))
		return
		
	if (!get_cvar_num("bot_quota"))
		return
		
	if (iHAM_CZ)
		return
		
	RegisterHamFromEntity(Ham_TraceAttack, id, "fw_PlayerTraceAttack")
	iHAM_CZ = 1	
}

/*				PRIMARY WPN				*/

public PW_UserCanTouchArmoury(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public PW_UserCanTouchWpnBox(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public PW_UserCanEquipPrimWpn(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}



/*				SECONDARY WPN				*/

public SW_UserCanEquipSecWpn(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public SW_UserCanTouchArmoury(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public SW_UserCanTouchWpnBox(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}


/*				MELEE WPN				*/

public MM_UserCanEquipMelee(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public MM_UserCanTouchArmoury(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public MM_UserCanTouchWpnBox(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

/*				GRENADE WPN				*/

public GM_UserCanEquipWpn(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public GM_UserCanTouchArmoury(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public GM_UserCanTouchWpnBox(id)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

/*				DEFAULT ARMOURY				*/
public DFWM_CanUserUseArmoury(id, iArmouryId)
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
	if (get_user_zombie(id))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}




/*		 		KNOCK-BACK SECTION			*/


public fw_PlayerTraceAttack(iVictim, iAttacker, Float:fDamage, Float:fDirection[3], tracehandle, damagebits)
{
	if (!zp_is_mode_on())
		return
		
	if (zp_get_round_state() == ROUND_END)
		return
		
	if (!is_user_connected(iAttacker) || !is_user_connected(iVictim))
		return
		
	new CsTeams:iAttackerTeam = cs_get_user_team(iAttacker)
	new CsTeams:iVictimTeam = cs_get_user_team(iVictim)
	
	if (iAttackerTeam == iVictimTeam)
		return
		
	new iWeaponEnt = get_pdata_cbase(iAttacker, m_pActiveItem, 5)
	
	if (!iWeaponEnt || !pev_valid(iWeaponEnt))
		return
		
	new iWeaponId = get_pdata_int(iWeaponEnt, m_iId, 4)
	
	new Float:fKnockBackPower, Float:fDistance
	new iEffectiveRange
	
	if (is_secondary_wpn(iWeaponId))
	{
		new iSecondaryWpnId = get_user_sec_wpn(iAttacker)
		
		if (iSecondaryWpnId < 0)
		{
			//	Weapon is the default secondary weapon of Counter Strike
			fKnockBackPower 	= 	Default_KbPower[iWeaponId]
			fDistance 		= 	float(Default_KbDistance[iWeaponId])
		}
		else
		{
			fKnockBackPower 	= 	get_sec_wpn_kb_power(iSecondaryWpnId)
			iEffectiveRange		=	get_sec_wpn_kb_distance(iSecondaryWpnId)
			fDistance 		= 	float(iEffectiveRange)
		}
	}
	else if (is_primary_wpn(iWeaponId))
	{
		new iPrimaryWpnId = get_user_pw(iAttacker)
		
		if (iPrimaryWpnId < 0)
		{
			//	Weapon is the default secondary weapon of Counter Strike
			fKnockBackPower 	= 	Default_KbPower[iWeaponId]
			fDistance 		= 	float(Default_KbDistance[iWeaponId])
		}
		else
		{
			fKnockBackPower 	= 	get_pw_kb_power(iPrimaryWpnId)
			iEffectiveRange		=	get_pw_kb_distance(iPrimaryWpnId)
			fDistance 		= 	float(iEffectiveRange)
		}
	}
	
	fKnockBackPower = get_pcvar_float(iCvarKnockBack)
	
	new iFLAG_Ducking
	iFLAG_Ducking = pev(iVictim, pev_flags) & (FL_DUCKING | FL_ONGROUND) == (FL_DUCKING | FL_ONGROUND)
	
	// Get distance between players
	new Float:fAttackerOrigin[3], Float:fVictimOrigin[3]
	pev(iAttacker, pev_origin, fAttackerOrigin)
	pev(iVictim, pev_origin, fVictimOrigin)
	
	new Float:fRealDistance = vector_distance(fAttackerOrigin, fVictimOrigin)
	
	if (fRealDistance >= fDistance )
	{
		return
	}
	
	new Float:fRealPower = fKnockBackPower - (fKnockBackPower / fDistance )*fRealDistance

	client_print(iAttacker, print_center, "%f %f %f", fRealDistance, fDistance, fRealPower)
	// Get victim's velocity
	new Float:velocity[3]
	pev(iVictim, pev_velocity, velocity)
	
	//xs_vec_mul_scalar(fDirection, fDamage, fDirection)
	
	//	Victim is ducking
	
	if (iFLAG_Ducking)
		xs_vec_mul_scalar(fDirection, 0.75, fDirection)
	xs_vec_mul_scalar(fDirection, fRealPower, fDirection)
	
	new iClassId = get_user_zombie_class(iVictim)
	xs_vec_mul_scalar(fDirection, get_class_kb(iClassId), fDirection)
	
	// Add up the new vector
	xs_vec_add(velocity, fDirection, fDirection)
	
	fDirection[2] = velocity[2]
	
	// Set the knockback'd victim's velocity
	set_pev(iVictim, pev_velocity, fDirection)
}

public AM_CalculatingArmorDmg(iVictim, iInflictor, iAttacker, Float:fDamage, iDamagebit)
{
	if (get_user_zombie(iAttacker))
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public AM_CanUserEquipArmor(id, iArmorId)
{
	if (get_user_zombie(id) && get_armor_team(iArmorId) != ARMOR_TEAM_ZOMBIE)
		return PLUGIN_HANDLED
		
	if (!get_user_zombie(id) && get_armor_team(iArmorId) != ARMOR_TEAM_SOLDIER)
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public AM_CanUserTouchArmor(id, iArmorId)
{
	if (get_user_zombie(id) && get_armor_team(iArmorId) != ARMOR_TEAM_ZOMBIE)
		return PLUGIN_HANDLED
		
	if (!get_user_zombie(id) && get_armor_team(iArmorId) != ARMOR_TEAM_SOLDIER)
		return PLUGIN_HANDLED
		
	return PLUGIN_CONTINUE
}

public CM_PlayCsRadioCode(iSender, iRecipient, szAudioCode[])
{
	if (!zp_is_mode_on())
		return PLUGIN_CONTINUE
		
		/*	Sender is Game Engine	*/
		
	if (!iSender)
	{
		if (!get_user_zombie(iRecipient))
			return PLUGIN_CONTINUE
			
		new iClassId = get_user_zombie_class(iRecipient)
		
		new iGender = get_class_gender(iClassId)
		play_radio_code(iSender, szAudioCode, 1, iGender, 1, ZOMBIE_MALE_RADIO, ZOMBIE_FEMALE_RADIO)
		return PLUGIN_HANDLED
	}
	
		/*	Sender is a player 	*/
		
	if (!get_user_zombie(iSender))
		return PLUGIN_CONTINUE
	
	new iClassId = get_user_zombie_class(iSender)
	new iGender = get_class_gender(iClassId)
	
	play_radio_code(iSender, szAudioCode, 1, iGender, 1, ZOMBIE_MALE_RADIO, ZOMBIE_FEMALE_RADIO)
	return PLUGIN_HANDLED
}
