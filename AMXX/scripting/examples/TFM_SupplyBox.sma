/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <fakemeta_util>
#include <hamsandwich>
#include <cstrike>
#include <engine>
#include <TFM_WPN>
#include <SDK_Hook>
#include <ArmouryManager>

#include <GamePlay_Included/Tools.inc>
#include <GamePlay_Included/TFM_ZombieMod.inc>
#include <mmcl>

#include <cswpn_info>
#include <cswpn_ultilities>

#define PLUGIN "SUPPLY BOX"
#define VERSION "-[No Info]-"
#define AUTHOR "Nguyen Duy Linh"

#define MAX_SPAWN_POINT 10


new g_TotalSpawns = 0

new Float:g_SpawnVecs[MAX_SPAWN_POINT][3]
new iIsVecUsing[MAX_SPAWN_POINT]

new PrimaryWpnEntity[][] = {"weapon_m3", "weapon_xm1014", "weapon_mp5navy", "weapon_tmp", "weapon_mac10", "weapon_p90", "weapon_ump45", "weapon_ak47", 
                         "weapon_m4a1", "weapon_galil", "weapon_famas", "weapon_scout", "weapon_awp", "weapon_sg552", "weapon_aug", "weapon_sg550",
			 "weapon_g3sg1", "weapon_m249"}

new SecondaryWpnEntity[][] = {"weapon_usp", "weapon_glock18", "weapon_deagle", "weapon_p228", "weapon_elite", "weapon_fiveseven"}

new GrenadeEntity[][] = {"weapon_hegrenade", "weapon_smokegrenade", "weapon_flashbang"}


/*		    DEFAULT CONSTANT			*/
#define MODEL_SUPPLY_BOX "models/TFM_SUPPLY-BOX.mdl"
#define SOUND_SUPPLY_BOX "events/SUPPLY-BOX_APPEAR.wav"
#define TRAIL_SUPPLY_BOX "sprites/shockwave.spr"
#define BOX_POS_DIRECTORY "SupplyBox"
 
#define SUPPLY_SET_TIME_1	10.0  // Use in : TDM 2 | FFA 2 
#define SUPPLY_SET_TIME_2	20.0  // Use in : Zombie Mod (Except Zombie United)

stock const SUPPLY_TRAIL_COLOR[3] = {255, 255, 255}

/********************************************************/


/*		    SPRITE | MODEL ID			*/

new iSPRID_SupplyTrail
new iMDLID_SupplyBox

/********************************************************/

/*		        TASK ID				*/
#define TASK_CREATE_SUPPLY	3000

/*		         VARIANTS			*/
new Float:fSupplyBoxSetTime


#define pev_iSupplyPoint pev_iuser1


public plugin_cfg() 
{
	if (!is_map_suitable())
	{
		set_fail_state("[Supply Box] Game-Play is not suitable")
		return 
	}

	
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_dictionary("TFM_Dictionary.txt")
	
	
	// Precache Model | Sprite
	iMDLID_SupplyBox = engfunc(EngFunc_PrecacheModel, MODEL_SUPPLY_BOX)
	iSPRID_SupplyTrail = engfunc(EngFunc_PrecacheModel, TRAIL_SUPPLY_BOX)
	
	
	// Client Command
	register_concmd("create_supply", "clcmd_CreateSupplyBox")
	
	
	// Hamsandiwch
	RegisterHam(Ham_Touch, "armoury_entity", "fw_SupplyBoxTouched")
	
	
	new szConfigdir[64], szMapName[32], szCfgFile[256]
	
	get_configsdir(szConfigdir, sizeof szConfigdir - 1)
	get_mapname(szMapName, sizeof szMapName - 1)
	
	formatex(szCfgFile,  sizeof szCfgFile - 1, "%s/%s/%s_spawns.cfg", szConfigdir, BOX_POS_DIRECTORY, szMapName)
	
	/*			Spawn point of Supply Box		*/
	
	if (file_exists(szCfgFile))
		load_point_from_file(szCfgFile)
	else
	{
		formatex(szCfgFile,  sizeof szCfgFile - 1, "%s/csdm/%s.spawns.cfg", szConfigdir, szMapName)
		
		if (file_exists(szCfgFile))
			load_point_from_file(szCfgFile)
	}
		
	if (g_TotalSpawns)
	{
		formatex(szCfgFile,  sizeof szCfgFile - 1, "%s/%s/%s_weapons.cfg", szConfigdir, BOX_POS_DIRECTORY, szMapName)
		
		if (file_exists(szCfgFile))
			load_weapon_file(szCfgFile)
	}
}




/*			CLIENT COMMAND				*/

public clcmd_CreateSupplyBox(id)
{
	if (!is_user_alive(id))
		return
		
	if (g_TotalSpawns > MAX_SPAWN_POINT - 1)
		return
		
	new szMapName[32], szConfigdir[64], szCfgFile[256]
	
	get_configsdir(szConfigdir, sizeof szConfigdir - 1)
	get_mapname(szMapName, sizeof szMapName - 1)
	
	formatex(szCfgFile, sizeof szCfgFile - 1, "%s/%s", szConfigdir, BOX_POS_DIRECTORY)
	
	if (!dir_exists(szCfgFile))
		mkdir(szCfgFile)
		
		
	if (!dir_exists(szCfgFile))
	{
		client_print(id, print_chat, "%L", id, "COULDNT_OPEN_DIR", szCfgFile)
		return
	}
	
	
	new iOrigin[3]
	new Float:fOrigin[3]
	
	pev(id, pev_origin, fOrigin)
	FVecIVec(fOrigin, iOrigin)
	
	g_SpawnVecs[g_TotalSpawns][0] = fOrigin[0]
	g_SpawnVecs[g_TotalSpawns][1] = fOrigin[1]
	g_SpawnVecs[g_TotalSpawns][2] = fOrigin[2]
	g_TotalSpawns++
	
	
	
	new szLine[128]
	formatex(szLine, sizeof szLine - 1, "%d %d %d", iOrigin[0], iOrigin[1], iOrigin[2])
	
	new iResult = write_file(szCfgFile, szLine, -1)
	
	if (!iResult)
	{
		client_print(id, print_chat, "%L", id, "COULDNT_WRITE_FILE", szCfgFile)
		return
	}
	
	create_supply_box(g_TotalSpawns)
	
	
}

/****************************************************************/


public RoundEvent_PreBegin()
{
	if (!g_TotalSpawns)
		return
		
	remove_task(TASK_CREATE_SUPPLY)
	
	
	for (new i = 0; i < g_TotalSpawns; i++)
		iIsVecUsing[i] = 0
	
}

public RoundEvent_Begin()
{
	if (!g_TotalSpawns)
		return
		
	remove_task(TASK_CREATE_SUPPLY)
	set_task(fSupplyBoxSetTime, "CreateSupplyBox_TASK", TASK_CREATE_SUPPLY)
}
	
public CreateSupplyBox_TASK(TASKID)
{
	if (!g_TotalSpawns)
		return
		
	new iRandomPoint = random(g_TotalSpawns - 1)
	
	if (iIsVecUsing[iRandomPoint])
	{
		set_task(fSupplyBoxSetTime, "CreateSupplyBox_TASK", TASK_CREATE_SUPPLY)
		return
	}
	
	create_supply_box(iRandomPoint)
	
	//create_blast_ring(g_SpawnVecs[iRandomPoint], SUPPLY_TRAIL_COLOR[0], SUPPLY_TRAIL_COLOR[1], SUPPLY_TRAIL_COLOR[2])
	
	
	client_cmd(0, "spk %s", SOUND_SUPPLY_BOX)
	client_print(0, print_center, "%L", LANG_SERVER, "SUPPLY_BOX_APPEARED")
	
	//	RE-SET TASK
	set_task(fSupplyBoxSetTime, "CreateSupplyBox_TASK", TASK_CREATE_SUPPLY)
}


public fw_SupplyBoxTouched(iEnt, id)
{
	if (!iEnt || !pev_valid(iEnt))
		return HAM_IGNORED
		
	if (pev(iEnt, pev_ArmouryType) != ARMOURY_SUPPLY)
		return HAM_IGNORED
		
	if (!is_user_connected(id))
		return HAM_SUPERCEDE
		
	if (!is_user_alive(id))
		return HAM_SUPERCEDE
		
	if (is_user_zombie(id))
		return HAM_SUPERCEDE
		
		
	new szName[32]
	get_user_name(id, szName, sizeof szName - 1)
		
	new iRandomType = random_num(1, 20)
	new iRandomWeapon
		
	switch (iRandomType) 
	{
		case 1	:
		{
			// PRIMARY WEAPON
			UT_DropPrimaryWeapon(id)
			iRandomWeapon = random(sizeof PrimaryWpnEntity)
			fm_give_item(id, PrimaryWpnEntity[iRandomWeapon])
			new iWeaponId = get_weaponid(PrimaryWpnEntity[iRandomWeapon])
			UT_SetUserBPA(id, iWeaponId, _Get_CSWPN_Bpa(iWeaponId))
			
			client_print(id, print_center, "%L", id, "CSRED_USER_RECEIVE_PRIMARY", DEFAULT_WEAPON_NAME[iWeaponId])
			
		}
		case 2	: //	GRENADE
		{
			iRandomWeapon = random(sizeof GrenadeEntity)
				
			new iWeaponId = get_weaponid(GrenadeEntity[iRandomWeapon])
				
			if (user_has_weapon(id, iWeaponId))
			{
				new iBpAmmo = cs_get_user_bpammo(id, iWeaponId)
				iBpAmmo++
					
				if (get_user_grenade(id, iWeaponId) > - 1)
					return HAM_SUPERCEDE
						
				cs_set_user_bpammo(id, iWeaponId, iBpAmmo)
			}
			else
			{
					
				fm_give_item(id, GrenadeEntity[iRandomWeapon])
					
				engclient_cmd(id, GrenadeEntity[iRandomWeapon])
			}
						
		}
		case 3, 11, 12, 13, 14,  9	:
		{
		
			new iPrimaryWpnId = get_pw_number()
			
			if (!iPrimaryWpnId)
				return HAM_SUPERCEDE
				
			UT_DropPrimaryWeapon(id)
			iRandomWeapon = random(iPrimaryWpnId - 1)
			new iResult = give_user_pw(id, iPrimaryWpnId)
				
			if (!iResult)
				return HAM_SUPERCEDE
					
			new szWeaponName[128]
			get_pw_name(iRandomWeapon, szWeaponName, sizeof szWeaponName - 1)
				
			client_print(id, print_center, "%L", id, "CSRED_USER_RECEIVE", szWeaponName)
				
			new iPlayers[32], iNumber
			get_players(iPlayers, iNumber, "ace", "CT")
			
		}
		case 4, 15, 16	:
		{
			iRandomWeapon = random(sizeof SecondaryWpnEntity)
			UT_DropSecondaryWeapon(id)
			fm_give_item(id, SecondaryWpnEntity[iRandomWeapon])
				
				
			new iWeaponId = get_weaponid(SecondaryWpnEntity[iRandomWeapon])
			UT_SetUserBPA(id, iWeaponId, _Get_CSWPN_Bpa(iWeaponId))
				
			engclient_cmd(id, SecondaryWpnEntity[iRandomWeapon])
				
			client_print(id, print_center, "%L", id, "CSRED_USER_RECEIVE", DEFAULT_WEAPON_NAME[iWeaponId])
				
			new iPlayers[32], iNumber
			get_players(iPlayers, iNumber, "ace", "CT")
					
		}
		case 5	:
		{	
			new iGrenadeCount = get_grenade_count()
				
			if (!iGrenadeCount)
				return HAM_SUPERCEDE
					
			iRandomWeapon = random(iGrenadeCount - 1)
			give_user_grenade(id, iRandomWeapon)
				
			new szWeaponName[128]
				
			get_grenade_name(iRandomWeapon, szWeaponName, sizeof szWeaponName - 1)
				
			client_print(id, print_center, "%L", id, "CSRED_USER_RECEIVE", szWeaponName)
				
		}
		case 6, 8, 17, 18, 7 ,19, 20:
		{
			
			new iSecondaryAmount = get_sec_wpn_number()
			
			if (!iSecondaryAmount)
				return HAM_SUPERCEDE
					
			UT_DropSecondaryWeapon(id)
			iRandomWeapon  = random(iSecondaryAmount - 1)
			new iResult = give_player_sec_wpn(id, iRandomWeapon)
				
			if (!iResult)
				return HAM_SUPERCEDE
					
			new szWeaponName[64]
			get_sec_wpn_name(iRandomWeapon, szWeaponName, sizeof szWeaponName - 1)
					
			client_print(id, print_center, "%L", id, "CSRED_USER_RECEIVE", szWeaponName)
				
		}
		/*
		case 10	:
		{
			
			client_print(id, print_center, "%L", id, "CSRED_USER_RELOAD_PRIMARY_NADE")
			
			new iPrimaryWpnId = get_user_pw(id)
			
			if (iPrimaryWpnId > - 1)
			{
				new iClip = get_pw_grenade_clip(iPrimaryWpnId)
				new iBpa = get_pw_grenade_bpa(iPrimaryWpnId)
				
				set_user_pw_grenade(id, iPrimaryWpnId, iClip, iBpa)
			}
			
			
		}
		*/
		default	:	{}
	}
	
	new iPoint = pev(iEnt, pev_iSupplyPoint)
	
	iIsVecUsing[iPoint] = 0
	
	engfunc(EngFunc_RemoveEntity, iEnt)
	return HAM_SUPERCEDE
}

stock create_blast_ring(const Float:originF[3], iRed, iGreen, iBlue)
{
	// Smallest ring
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, originF, 0)
	write_byte(TE_BEAMCYLINDER) // TE id
	engfunc(EngFunc_WriteCoord, originF[0]) // x
	engfunc(EngFunc_WriteCoord, originF[1]) // y
	engfunc(EngFunc_WriteCoord, originF[2]) // z
	engfunc(EngFunc_WriteCoord, originF[0]) // x axis
	engfunc(EngFunc_WriteCoord, originF[1]) // y axis
	engfunc(EngFunc_WriteCoord, originF[2] + 100.0) // z axis
	write_short(iSPRID_SupplyTrail) // sprite
	write_byte(0) // startframe
	write_byte(0) // framerate
	write_byte(4) // life
	write_byte(10) // width
	write_byte(0) // noise
	write_byte(iRed) // red
	write_byte(iGreen) // green
	write_byte(iBlue) // blue
	write_byte(200) // brightness
	write_byte(0) // speed
	message_end()
}



stock load_weapon_file(szFile[])
{
	if (!file_exists(szFile))
		return
		
	new iTRASH, szText[128]
	
	for (new i = 0; i < file_size(szFile, 1); i++)
	{
		read_file(szFile, i, szText, sizeof szText - 1, iTRASH)
		
		if (equal(szText, "[primary_wpn]", 13))
		{
			replace(szText, sizeof szText - 1, "[primary_wpn]", "")
			set_pw_load_file(szText, "ini")
			
		}
		else if (equal(szText, "[secondary_wpn]", 15))
		{
			replace(szText, sizeof szText - 1, "[secondary_wpn]", "")
			set_sec_wpn_load_file(szText, "ini")
		}
		else if (equal(szText, "[melee]", 7))
		{
			replace(szText, sizeof szText - 1, "[melee_mdl]", "")
			set_melee_load_file(szText, "ini")
		}
		else if (equal(szText, "[grenade]", 9))
		{
			replace(szText, sizeof szText - 1, "[GRENADE]", "")
			load_grenade_file(szFile, "ini")
		}
	}
}

stock get_model_size(filename[],Float:vec[3])
{
	new file = fopen(filename,"rb")
	fseek(file,160,SEEK_SET)
	new bboff
	fread(file,bboff,BLOCK_INT)
	fseek(file,bboff+8,SEEK_SET)
	new Float:size[6]
	fread_blocks(file,_:size,6,BLOCK_INT)
	fclose(file)
	vec[0]=size[3]-size[0]
	vec[1]=size[4]-size[1]
	vec[2]=size[5]-size[2]
}



stock is_map_suitable()
{
	switch (get_current_gameplay())
	{
		case GAMEMODE_FFA:
		{
			
			fSupplyBoxSetTime = SUPPLY_SET_TIME_1
			return 0
		}
		case GAMEMODE_TDM:
		{
			fSupplyBoxSetTime = SUPPLY_SET_TIME_1
			return 0
			
		}
		case GAMEMODE_ZM:
		{
			new iZM_GamePlay = zp_get_current_gameplay()
			
			if (iZM_GamePlay != ZB_GAMEPLAY_UNITED_1)
			{
				fSupplyBoxSetTime = SUPPLY_SET_TIME_2
				return 1
			}	
		}
	}
	
	return 0
}

stock create_supply_box(iPoint)
{
	if (iPoint < 0 || iPoint > g_TotalSpawns - 1)
		return 0
		
	new iEnt = create_entity("armoury_entity")
	
	if (!iEnt || !pev_valid(iEnt))
		return 0
		
	
	
	dllfunc( DLLFunc_Spawn, iEnt );
	
	new Float:fSizeMin[3]
	new Float:fSizeMax[3]
	
	fSizeMin[0] = -13.370000
	fSizeMin[1] = -17.650000 
	fSizeMin[2] = -5.150000
	
	fSizeMax[0] = 11.690000
	fSizeMax[1] = 22.299999
	fSizeMax[2] = 4.110000
	
	set_pev(iEnt, pev_solid, SOLID_TRIGGER)
	
	set_pev(iEnt, pev_mins, fSizeMin)
	
	set_pev(iEnt, pev_maxs, fSizeMax)
	
	set_pev(iEnt, pev_ArmouryType, ARMOURY_SUPPLY)
	
	csred_SetArmouryStatus(iEnt, ARMOURY_ENABLED)
				
	engfunc(EngFunc_SetModel, iEnt, MODEL_SUPPLY_BOX)
	
	set_pev(iEnt, pev_modelindex, iMDLID_SupplyBox)

	set_pev(iEnt, pev_origin, g_SpawnVecs[iPoint])
	engfunc(EngFunc_DropToFloor, iEnt)
	return 1
	
}

stock load_point_from_file(szCfgFile[])
{
	
	for (new i = 0; i < file_size(szCfgFile, 1) ; i++)
	{
		if (g_TotalSpawns >= MAX_SPAWN_POINT)
			return
			
		new szTextInfo[32], iTextLen
		new szPos_X[10], szPos_Y[10], szPos_Z[10]
			
		read_file(szCfgFile, i, szTextInfo, sizeof szTextInfo - 1, iTextLen)
		parse(szTextInfo, szPos_X, sizeof szPos_X - 1, szPos_Y, sizeof szPos_Y - 1, szPos_Z, sizeof szPos_Z - 1)
			
		// Origin
		g_SpawnVecs[g_TotalSpawns][0] = str_to_float(szPos_X)
		g_SpawnVecs[g_TotalSpawns][1] = str_to_float(szPos_Y)
		g_SpawnVecs[g_TotalSpawns][2] = str_to_float(szPos_Z)
		iIsVecUsing[g_TotalSpawns] = 0
			
		g_TotalSpawns++
	}
}
